'\" t
.\"     Title: DELETE
.\"    Author: The PostgreSQL Global Development Group
.\" Generator: DocBook XSL Stylesheets v1.75.1 <http://docbook.sf.net/>
.\"      Date: 2010-09-16
.\"    Manual: PostgreSQL 9.0.0 Documentation
.\"    Source: PostgreSQL 9.0.0
.\"  Language: English
.\"
.TH "DELETE" "7" "2010-09-16" "PostgreSQL 9.0.0" "PostgreSQL 9.0.0 Documentation"
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
DELETE \- delete rows of a table
.\" DELETE
.SH "SYNOPSIS"
.sp
.nf
DELETE FROM [ ONLY ] \fItable\fR [ [ AS ] \fIalias\fR ]
    [ USING \fIusing_list\fR ]
    [ WHERE \fIcondition\fR | WHERE CURRENT OF \fIcursor_name\fR ]
    [ RETURNING * | \fIoutput_expression\fR [ [ AS ] \fIoutput_name\fR ] [, \&.\&.\&.] ]
.fi
.SH "DESCRIPTION"
.PP
DELETE
deletes rows that satisfy the
WHERE
clause from the specified table\&. If the
WHERE
clause is absent, the effect is to delete all rows in the table\&. The result is a valid, but empty table\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBTip\fR
.ps -1
.br
.PP
\fBTRUNCATE\fR(7)
is a
PostgreSQL
extension that provides a faster mechanism to remove all rows from a table\&.
.sp .5v
.RE
.PP
By default,
DELETE
will delete rows in the specified table and all its child tables\&. If you wish to delete only from the specific table mentioned, you must use the
ONLY
clause\&.
.PP
There are two ways to delete rows in a table using information contained in other tables in the database: using sub\-selects, or specifying additional tables in the
USING
clause\&. Which technique is more appropriate depends on the specific circumstances\&.
.PP
The optional
RETURNING
clause causes
DELETE
to compute and return value(s) based on each row actually deleted\&. Any expression using the table\(aqs columns, and/or columns of other tables mentioned in
USING, can be computed\&. The syntax of the
RETURNING
list is identical to that of the output list of
SELECT\&.
.PP
You must have the
DELETE
privilege on the table to delete from it, as well as the
SELECT
privilege for any table in the
USING
clause or whose values are read in the
\fIcondition\fR\&.
.SH "PARAMETERS"
.PP
ONLY
.RS 4
If specified, delete rows from the named table only\&. When not specified, any tables inheriting from the named table are also processed\&.
.RE
.PP
\fItable\fR
.RS 4
The name (optionally schema\-qualified) of an existing table\&.
.RE
.PP
\fIalias\fR
.RS 4
A substitute name for the target table\&. When an alias is provided, it completely hides the actual name of the table\&. For example, given
DELETE FROM foo AS f, the remainder of the
DELETE
statement must refer to this table as
f
not
foo\&.
.RE
.PP
\fIusing_list\fR
.RS 4
A list of table expressions, allowing columns from other tables to appear in the
WHERE
condition\&. This is similar to the list of tables that can be specified in the
FROM Clause
of a
SELECT
statement; for example, an alias for the table name can be specified\&. Do not repeat the target table in the
\fIusing_list\fR, unless you wish to set up a self\-join\&.
.RE
.PP
\fIcondition\fR
.RS 4
An expression that returns a value of type
boolean\&. Only rows for which this expression returns
true
will be deleted\&.
.RE
.PP
\fIcursor_name\fR
.RS 4
The name of the cursor to use in a
WHERE CURRENT OF
condition\&. The row to be deleted is the one most recently fetched from this cursor\&. The cursor must be a non\-grouping query on the
DELETE\(aqs target table\&. Note that
WHERE CURRENT OF
cannot be specified together with a Boolean condition\&. See
\fBDECLARE\fR(7)
for more information about using cursors with
WHERE CURRENT OF\&.
.RE
.PP
\fIoutput_expression\fR
.RS 4
An expression to be computed and returned by the
DELETE
command after each row is deleted\&. The expression can use any column names of the
\fItable\fR
or table(s) listed in
USING\&. Write
*
to return all columns\&.
.RE
.PP
\fIoutput_name\fR
.RS 4
A name to use for a returned column\&.
.RE
.SH "OUTPUTS"
.PP
On successful completion, a
DELETE
command returns a command tag of the form
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE \fIcount\fR
.fi
.if n \{\
.RE
.\}
.sp
The
\fIcount\fR
is the number of rows deleted\&. If
\fIcount\fR
is 0, no rows matched the
\fIcondition\fR
(this is not considered an error)\&.
.PP
If the
DELETE
command contains a
RETURNING
clause, the result will be similar to that of a
SELECT
statement containing the columns and values defined in the
RETURNING
list, computed over the row(s) deleted by the command\&.
.SH "NOTES"
.PP
PostgreSQL
lets you reference columns of other tables in the
WHERE
condition by specifying the other tables in the
USING
clause\&. For example, to delete all films produced by a given producer, one can do:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films USING producers
  WHERE producer_id = producers\&.id AND producers\&.name = \(aqfoo\(aq;
.fi
.if n \{\
.RE
.\}
.sp
What is essentially happening here is a join between
films
and
producers, with all successfully joined
films
rows being marked for deletion\&. This syntax is not standard\&. A more standard way to do it is:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films
  WHERE producer_id IN (SELECT id FROM producers WHERE name = \(aqfoo\(aq);
.fi
.if n \{\
.RE
.\}
.sp
In some cases the join style is easier to write or faster to execute than the sub\-select style\&.
.SH "EXAMPLES"
.PP
Delete all films but musicals:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films WHERE kind <> \(aqMusical\(aq;
.fi
.if n \{\
.RE
.\}
.PP
Clear the table
films:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM films;
.fi
.if n \{\
.RE
.\}
.PP
Delete completed tasks, returning full details of the deleted rows:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM tasks WHERE status = \(aqDONE\(aq RETURNING *;
.fi
.if n \{\
.RE
.\}
.PP
Delete the row of
tasks
on which the cursor
c_tasks
is currently positioned:
.sp
.if n \{\
.RS 4
.\}
.nf
DELETE FROM tasks WHERE CURRENT OF c_tasks;
.fi
.if n \{\
.RE
.\}
.SH "COMPATIBILITY"
.PP
This command conforms to the
SQL
standard, except that the
USING
and
RETURNING
clauses are
PostgreSQL
extensions\&.
