<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>C-Language Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.0.0 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="Internal Functions"
HREF="xfunc-internal.html"><LINK
REL="NEXT"
TITLE="User-Defined Aggregates"
HREF="xaggr.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2010-09-17T01:31:37"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.0.0 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Internal Functions"
HREF="xfunc-internal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Extending SQL"
HREF="extend.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 35. Extending <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Extending SQL"
HREF="extend.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="User-Defined Aggregates"
HREF="xaggr.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-C"
>35.9. C-Language Functions</A
></H1
><P
>    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <SPAN
CLASS="QUOTE"
>"C language"</SPAN
> functions
    from <SPAN
CLASS="QUOTE"
>"internal"</SPAN
> functions &mdash; the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
   </P
><P
>    Two different calling conventions are currently used for C functions.
    The newer <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
> calling convention is indicated by writing
    a <TT
CLASS="LITERAL"
>PG_FUNCTION_INFO_V1()</TT
> macro call for the function,
    as illustrated below.  Lack of such a macro indicates an old-style
    (<SPAN
CLASS="QUOTE"
>"version 0"</SPAN
>) function.  The language name specified in <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    is <TT
CLASS="LITERAL"
>C</TT
> in either case.  Old-style functions are now deprecated
    because of portability problems and lack of functionality, but they
    are still supported for compatibility reasons.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-DYNLOAD"
>35.9.1. Dynamic Loading</A
></H2
><P
>    The first time a user-defined function in a particular
    loadable object file is called in a session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
   </P
><P
>    The following algorithm is used to locate the shared object file
    based on the name given in the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>
    command:

    <P
></P
></P><OL
TYPE="1"
><LI
><P
>       If the name is an absolute path, the given file is loaded.
      </P
></LI
><LI
><P
>       If the name starts with the string <TT
CLASS="LITERAL"
>$libdir</TT
>,
       that part is replaced by the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> package
        library directory
       name, which is determined at build time.
      </P
></LI
><LI
><P
>       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <A
HREF="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH"
>dynamic_library_path</A
>.
      </P
></LI
><LI
><P
>       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
      </P
></LI
></OL
><P>

    If this sequence does not work, the platform-specific shared
    library file name extension (often <TT
CLASS="FILENAME"
>.so</TT
>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
   </P
><P
>    It is recommended to locate shared libraries either relative to
    <TT
CLASS="LITERAL"
>$libdir</TT
> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <TT
CLASS="LITERAL"
>$libdir</TT
> stands for can be found out with the
    command <TT
CLASS="LITERAL"
>pg_config --pkglibdir</TT
>.
   </P
><P
>    The user ID the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server runs
    as must be able to traverse the path to the file you intend to
    load.  Making the file or a higher-level directory not readable
    and/or not executable by the <SPAN
CLASS="SYSTEMITEM"
>postgres</SPAN
>
    user is a common mistake.
   </P
><P
>    In any case, the file name that is given in the
    <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <TT
CLASS="COMMAND"
>CREATE
     FUNCTION</TT
> command.  See <A
HREF="xfunc-c.html#DFUNC"
>Section 35.9.6</A
> for additional
     information.
    </P
></BLOCKQUOTE
></DIV
><P
>    To ensure that a dynamically loaded object file is not loaded into an
    incompatible server, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> checks that the
    file contains a <SPAN
CLASS="QUOTE"
>"magic block"</SPAN
> with the appropriate contents.
    This allows the server to detect obvious incompatibilities, such as code
    compiled for a different major version of
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.  A magic block is required as of
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.2.  To include a magic block,
    write this in one (and only one) of the module source files, after having
    included the header <TT
CLASS="FILENAME"
>fmgr.h</TT
>:

</P><PRE
CLASS="PROGRAMLISTING"
>#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif</PRE
><P>

    The <TT
CLASS="LITERAL"
>#ifdef</TT
> test can be omitted if the code doesn't
    need to compile against pre-8.2 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    releases.
   </P
><P
>    After it is used for the first time, a dynamically loaded object
    file is retained in memory.  Future calls in the same session to
    the function(s) in that file will only incur the small overhead of
    a symbol table lookup.  If you need to force a reload of an object
    file, for example after recompiling it, begin a fresh session.
   </P
><P
>    Optionally, a dynamically loaded file can contain initialization and
    finalization functions.  If the file includes a function named
    <CODE
CLASS="FUNCTION"
>_PG_init</CODE
>, that function will be called immediately after
    loading the file.  The function receives no parameters and should
    return void.  If the file includes a function named
    <CODE
CLASS="FUNCTION"
>_PG_fini</CODE
>, that function will be called immediately before
    unloading the file.  Likewise, the function receives no parameters and
    should return void.  Note that <CODE
CLASS="FUNCTION"
>_PG_fini</CODE
> will only be called
    during an unload of the file, not during process termination.
    (Presently, unloads are disabled and will never occur, but this may
    change in the future.)
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-BASETYPE"
>35.9.2. Base Types in C-Language Functions</A
></H2
><P
>     To know how to write C-language functions, you need to know how
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> internally represents base
     data types and how they can be passed to and from functions.
     Internally, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> regards a base
     type as a <SPAN
CLASS="QUOTE"
>"blob of memory"</SPAN
>.  The user-defined
     functions that you define over a type in turn define the way that
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> can operate on it.  That
     is, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> will only store and
     retrieve the data from disk and use your user-defined functions
     to input, process, and output the data.
    </P
><P
>     Base types can have one of three internal formats:

     <P
></P
></P><UL
><LI
><P
>        pass by value, fixed-length
       </P
></LI
><LI
><P
>        pass by reference, fixed-length
       </P
></LI
><LI
><P
>        pass by reference, variable-length
       </P
></LI
></UL
><P>
    </P
><P
>     By-value  types  can  only be 1, 2, or 4 bytes in length
     (also 8 bytes, if <TT
CLASS="LITERAL"
>sizeof(Datum)</TT
> is 8 on your machine).
     You should be careful to define your types such that they will be the
     same size (in bytes) on all architectures.  For example, the
     <TT
CLASS="LITERAL"
>long</TT
> type is dangerous because it is 4 bytes on some
     machines and 8 bytes on others, whereas <TT
CLASS="TYPE"
>int</TT
> type is 4 bytes
     on most Unix machines.  A reasonable implementation of the
     <TT
CLASS="TYPE"
>int4</TT
> type on Unix machines might be:

</P><PRE
CLASS="PROGRAMLISTING"
>/* 4-byte integer, passed by value */
typedef int int4;</PRE
><P>
    </P
><P
>     On  the  other hand, fixed-length types of any size can
     be passed by-reference.  For example, here is a  sample
     implementation of a <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> type:

</P><PRE
CLASS="PROGRAMLISTING"
>/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;</PRE
><P>

     Only  pointers  to  such types can be used when passing
     them in and out of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> functions.
     To return a value of such a type, allocate the right amount of
     memory with <TT
CLASS="LITERAL"
>palloc</TT
>, fill in the allocated memory,
     and return a pointer to it.  (Also, if you just want to return the
     same value as one of your input arguments that's of the same data type,
     you can skip the extra <TT
CLASS="LITERAL"
>palloc</TT
> and just return the
     pointer to the input value.)
    </P
><P
>     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with a length field of exactly 4 bytes, and all data to
     be  stored within that type must be located in the memory
     immediately  following  that  length  field.   The
     length field contains the total length of the structure,
     that is,  it  includes  the  size  of  the  length  field
     itself.
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Never</I
></SPAN
> modify the contents of a pass-by-reference input
      value.  If you do so you are likely to corrupt on-disk data, since
      the pointer you are given might point directly into a disk buffer.
      The sole exception to this rule is explained in
      <A
HREF="xaggr.html"
>Section 35.10</A
>.
     </P
></TD
></TR
></TABLE
></DIV
><P
>     As an example, we can define the type <TT
CLASS="TYPE"
>text</TT
> as
     follows:

</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct {
    int4 length;
    char data[1];
} text;</PRE
><P>

     Obviously,  the  data  field declared here is not long enough to hold
     all possible strings.  Since it's impossible to declare a variable-size
     structure in <ACRONYM
CLASS="ACRONYM"
>C</ACRONYM
>, we rely on the knowledge that the
     <ACRONYM
CLASS="ACRONYM"
>C</ACRONYM
> compiler won't range-check array subscripts.  We
     just allocate the necessary amount of space and then access the array as
     if it were declared the right length.  (This is a common trick, which
     you can read about in many textbooks about C.)
    </P
><P
>     When manipulating
     variable-length types, we must  be  careful  to  allocate
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a <TT
CLASS="STRUCTNAME"
>text</TT
>
     structure, we might use a code fragment like this:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
destination-&#62;length = VARHDRSZ + 40;
memcpy(destination-&#62;data, buffer, 40);
...</PRE
><P>

     <TT
CLASS="LITERAL"
>VARHDRSZ</TT
> is the same as <TT
CLASS="LITERAL"
>sizeof(int4)</TT
>, but
     it's considered good style to use the macro <TT
CLASS="LITERAL"
>VARHDRSZ</TT
>
     to refer to the size of the overhead for a variable-length type.
    </P
><P
>     <A
HREF="xfunc-c.html#XFUNC-C-TYPE-TABLE"
>Table 35-1</A
> specifies which C type
     corresponds to which SQL type when writing a C-language function
     that uses a built-in type of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.
     The <SPAN
CLASS="QUOTE"
>"Defined In"</SPAN
> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition might be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <TT
CLASS="FILENAME"
>postgres.h</TT
> first in any source file, because
     it declares a number of things that you will need anyway.
    </P
><DIV
CLASS="TABLE"
><A
NAME="XFUNC-C-TYPE-TABLE"
></A
><P
><B
>Table 35-1. Equivalent C Types for Built-In SQL Types</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>          SQL Type
         </TH
><TH
>          C Type
         </TH
><TH
>          Defined In
         </TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>abstime</TT
></TD
><TD
><TT
CLASS="TYPE"
>AbsoluteTime</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
> (maybe compiler built-in)</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>box</TT
></TD
><TD
><TT
CLASS="TYPE"
>BOX*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
><TT
CLASS="TYPE"
>bytea*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>"char"</TT
></TD
><TD
><TT
CLASS="TYPE"
>char</TT
></TD
><TD
>(compiler built-in)</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>character</TT
></TD
><TD
><TT
CLASS="TYPE"
>BpChar*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>cid</TT
></TD
><TD
><TT
CLASS="TYPE"
>CommandId</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
><TT
CLASS="TYPE"
>DateADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>smallint</TT
> (<TT
CLASS="TYPE"
>int2</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>int2</TT
> or <TT
CLASS="TYPE"
>int16</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>int2vector</TT
></TD
><TD
><TT
CLASS="TYPE"
>int2vector*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>integer</TT
> (<TT
CLASS="TYPE"
>int4</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>int4</TT
> or <TT
CLASS="TYPE"
>int32</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>real</TT
> (<TT
CLASS="TYPE"
>float4</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>float4*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>double precision</TT
> (<TT
CLASS="TYPE"
>float8</TT
>)</TD
><TD
><TT
CLASS="TYPE"
>float8*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
><TT
CLASS="TYPE"
>Interval*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>lseg</TT
></TD
><TD
><TT
CLASS="TYPE"
>LSEG*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>name</TT
></TD
><TD
><TT
CLASS="TYPE"
>Name</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
><TT
CLASS="TYPE"
>Oid</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>oidvector</TT
></TD
><TD
><TT
CLASS="TYPE"
>oidvector*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>path</TT
></TD
><TD
><TT
CLASS="TYPE"
>PATH*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>point</TT
></TD
><TD
><TT
CLASS="TYPE"
>POINT*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/geo_decls.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="TYPE"
>regproc</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>reltime</TT
></TD
><TD
><TT
CLASS="TYPE"
>RelativeTime</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><TT
CLASS="TYPE"
>text*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>tid</TT
></TD
><TD
><TT
CLASS="TYPE"
>ItemPointer</TT
></TD
><TD
><TT
CLASS="FILENAME"
>storage/itemptr.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeTzADT</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/date.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
><TT
CLASS="TYPE"
>Timestamp*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/timestamp.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>tinterval</TT
></TD
><TD
><TT
CLASS="TYPE"
>TimeInterval</TT
></TD
><TD
><TT
CLASS="FILENAME"
>utils/nabstime.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>varchar</TT
></TD
><TD
><TT
CLASS="TYPE"
>VarChar*</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>xid</TT
></TD
><TD
><TT
CLASS="TYPE"
>TransactionId</TT
></TD
><TD
><TT
CLASS="FILENAME"
>postgres.h</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN46715"
>35.9.3. Version 0 Calling Conventions</A
></H2
><P
>     We present the <SPAN
CLASS="QUOTE"
>"old style"</SPAN
> calling convention first &mdash; although
     this approach is now deprecated, it's easier to get a handle on
     initially.  In the version-0 method, the arguments and result
     of the C function are just declared in normal C style, but being
     careful to use the C representation of each SQL data type as shown
     above.
    </P
><P
>     Here are some examples:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &#60;string.h&#62;
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* by value */

int
add_one(int arg)
{
    return arg + 1;
}

/* by reference, fixed length */

float8 *
add_one_float8(float8 *arg)
{
    float8    *result = (float8 *) palloc(sizeof(float8));

    *result = *arg + 1.0;

    return result;
}

Point *
makepoint(Point *pointx, Point *pointy)
{
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    return new_point;
}

/* by reference, variable length */

text *
copytext(text *t)
{
    /*
     * VARSIZE is the total size of the struct in bytes.
     */
    text *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));
    /*
     * VARDATA is a pointer to the data region of the struct.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t) - VARHDRSZ);  /* how many bytes */
    return new_t;
}

text *
concat_text(text *arg1, text *arg2)
{
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    return new_text;
}</PRE
><P>
    </P
><P
>     Supposing that the above code has been prepared in file
     <TT
CLASS="FILENAME"
>funcs.c</TT
> and compiled into a shared object,
     we could define the functions to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
     with commands like this:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- note overloading of SQL function name "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'concat_text'
     LANGUAGE C STRICT;</PRE
><P>
    </P
><P
>     Here, <TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
> stands for the
     directory of the shared library file (for instance the
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> tutorial directory, which
     contains the code for the examples used in this section).
     (Better style would be to use just <TT
CLASS="LITERAL"
>'funcs'</TT
> in the
     <TT
CLASS="LITERAL"
>AS</TT
> clause, after having added
     <TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
> to the search path.  In any
     case, we can omit the system-specific extension for a shared
     library, commonly <TT
CLASS="LITERAL"
>.so</TT
> or
     <TT
CLASS="LITERAL"
>.sl</TT
>.)
    </P
><P
>     Notice that we have specified the functions as <SPAN
CLASS="QUOTE"
>"strict"</SPAN
>,
     meaning that
     the system should automatically assume a null result if any input
     value is null.  By doing this, we avoid having to check for null inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, by checking for a null pointer for each
     pass-by-reference argument.  (For pass-by-value arguments, we don't
     even have a way to check!)
    </P
><P
>     Although this calling convention is simple to use,
     it is not very portable; on some architectures there are problems
     with passing data types that are smaller than <TT
CLASS="TYPE"
>int</TT
> this way.  Also, there is
     no simple way to return a null result, nor to cope with null arguments
     in any way other than making the function strict.  The version-1
     convention, presented next, overcomes these objections.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN46742"
>35.9.4. Version 1 Calling Conventions</A
></H2
><P
>     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always:
</P><PRE
CLASS="PROGRAMLISTING"
>Datum funcname(PG_FUNCTION_ARGS)</PRE
><P>
     In addition, the macro call:
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(funcname);</PRE
><P>
     must appear in the same source file.  (Conventionally, it's
     written just before the function itself.)  This macro call is not
     needed for <TT
CLASS="LITERAL"
>internal</TT
>-language functions, since
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> assumes that all internal functions
     use the version-1 convention.  It is, however, required for
     dynamically-loaded functions.
    </P
><P
>     In a version-1 function, each actual argument is fetched using a
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     macro that corresponds to the argument's data type, and the
     result is returned using a
     <CODE
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     macro for the return type.
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     takes as its argument the number of the function argument to
     fetch, where the count starts at 0.
     <CODE
CLASS="FUNCTION"
>PG_RETURN_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     takes as its argument the actual value to return.
    </P
><P
>     Here we show the same functions as above, coded in version-1 style:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include &#60;string.h&#62;
#include "fmgr.h"
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* by value */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* by reference, fixed length */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* The macros for FLOAT8 hide its pass-by-reference nature. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Here, the pass-by-reference nature of Point is not hidden. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&#62;x = pointx-&#62;x;
    new_point-&#62;y = pointy-&#62;y;

    PG_RETURN_POINT_P(new_point);
}

/* by reference, variable length */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_P(0);
    /*
     * VARSIZE is the total size of the struct in bytes.
     */
    text     *new_t = (text *) palloc(VARSIZE(t));
    SET_VARSIZE(new_t, VARSIZE(t));
    /*
     * VARDATA is a pointer to the data region of the struct.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA(t),     /* source */
           VARSIZE(t) - VARHDRSZ);  /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_P(0);
    text  *arg2 = PG_GETARG_TEXT_P(1);
    int32 new_text_size = VARSIZE(arg1) + VARSIZE(arg2) - VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA(arg1), VARSIZE(arg1) - VARHDRSZ);
    memcpy(VARDATA(new_text) + (VARSIZE(arg1) - VARHDRSZ),
           VARDATA(arg2), VARSIZE(arg2) - VARHDRSZ);
    PG_RETURN_TEXT_P(new_text);
}</PRE
><P>
    </P
><P
>     The <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> commands are the same as
     for the version-0 equivalents.
    </P
><P
>     At first glance, the version-1 coding conventions might appear to
     be just pointless obscurantism.  They do, however, offer a number
     of improvements, because the macros can hide unnecessary detail.
     An example is that in coding <CODE
CLASS="FUNCTION"
>add_one_float8</CODE
>, we no longer need to
     be aware that <TT
CLASS="TYPE"
>float8</TT
> is a pass-by-reference type.  Another
     example is that the <TT
CLASS="LITERAL"
>GETARG</TT
> macros for variable-length types allow
     for more efficient fetching of <SPAN
CLASS="QUOTE"
>"toasted"</SPAN
> (compressed or
     out-of-line) values.
    </P
><P
>     One big improvement in version-1 functions is better handling of null
     inputs and results.  The macro <CODE
CLASS="FUNCTION"
>PG_ARGISNULL(<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)</CODE
>
     allows a function to test whether each input is null.  (Of course, doing
     this is only necessary in functions not declared <SPAN
CLASS="QUOTE"
>"strict"</SPAN
>.)
     As with the
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
> until
     one has verified that the argument isn't null.
     To return a null result, execute <CODE
CLASS="FUNCTION"
>PG_RETURN_NULL()</CODE
>;
     this works in both strict and nonstrict functions.
    </P
><P
>     Other options provided in the new-style interface are two
     variants of the
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>()</CODE
>
     macros. The first of these,
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</CODE
>,
     guarantees to return a copy of the specified argument that is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, which
     must not be written to. Using the
     <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_COPY()</CODE
>
     macros guarantees a writable result.)
    The second variant consists of the
    <CODE
CLASS="FUNCTION"
>PG_GETARG_<TT
CLASS="REPLACEABLE"
><I
>xxx</I
></TT
>_SLICE()</CODE
>
    macros which take three arguments. The first is the number of the
    function argument (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These macros provide more efficient access to
    parts of large values in the case where they have storage type
    <SPAN
CLASS="QUOTE"
>"external"</SPAN
>. (The storage type of a column can be specified using
    <TT
CLASS="LITERAL"
>ALTER TABLE <TT
CLASS="REPLACEABLE"
><I
>tablename</I
></TT
> ALTER
    COLUMN <TT
CLASS="REPLACEABLE"
><I
>colname</I
></TT
> SET STORAGE
    <TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
></TT
>. <TT
CLASS="REPLACEABLE"
><I
>storagetype</I
></TT
> is one of
    <TT
CLASS="LITERAL"
>plain</TT
>, <TT
CLASS="LITERAL"
>external</TT
>, <TT
CLASS="LITERAL"
>extended</TT
>,
     or <TT
CLASS="LITERAL"
>main</TT
>.)
    </P
><P
>     Finally, the version-1 function call conventions make it possible
     to return set results (<A
HREF="xfunc-c.html#XFUNC-C-RETURN-SET"
>Section 35.9.10</A
>) and
     implement trigger functions (<A
HREF="triggers.html"
>Chapter 36</A
>) and
     procedural-language call handlers (<A
HREF="plhandler.html"
>Chapter 49</A
>).  Version-1 code is also more
     portable than version-0, because it does not break restrictions
     on function call protocol in the C standard.  For more details
     see <TT
CLASS="FILENAME"
>src/backend/utils/fmgr/README</TT
> in the
     source distribution.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN46800"
>35.9.5. Writing Code</A
></H2
><P
>     Before we turn to the more advanced topics, we should discuss
     some coding rules for <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
     C-language functions.  While it might be possible to load functions
     written in languages other than C into
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, this is usually difficult
     (when it is possible at all) because other languages, such as
     C++, FORTRAN, or Pascal often do not follow the same calling
     convention as C.  That is, other languages do not pass argument
     and return values between functions in the same way.  For this
     reason, we will assume that your C-language functions are
     actually written in C.
    </P
><P
>     The basic rules for writing and building C functions are as follows:

     <P
></P
></P><UL
><LI
><P
>        Use <TT
CLASS="LITERAL"
>pg_config
        --includedir-server</TT
>
        to find out where the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server header
        files are installed on your system (or the system that your
        users will be running on).
       </P
></LI
><LI
><P
>        Compiling and linking your code so that it can be dynamically
        loaded into <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> always
        requires special flags.  See <A
HREF="xfunc-c.html#DFUNC"
>Section 35.9.6</A
> for a
        detailed explanation of how to do it for your particular
        operating system.
       </P
></LI
><LI
><P
>        Remember to define a <SPAN
CLASS="QUOTE"
>"magic block"</SPAN
> for your shared library,
        as described in <A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>Section 35.9.1</A
>.
       </P
></LI
><LI
><P
>        When allocating memory, use the
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> functions
        <CODE
CLASS="FUNCTION"
>palloc</CODE
> and <CODE
CLASS="FUNCTION"
>pfree</CODE
>
        instead of the corresponding C library functions
        <CODE
CLASS="FUNCTION"
>malloc</CODE
> and <CODE
CLASS="FUNCTION"
>free</CODE
>.
        The memory allocated by <CODE
CLASS="FUNCTION"
>palloc</CODE
> will be
        freed automatically at the end of each transaction, preventing
        memory leaks.
       </P
></LI
><LI
><P
>        Always zero the bytes of your structures using
        <CODE
CLASS="FUNCTION"
>memset</CODE
>.  Without this, it's difficult to
        support hash indexes or hash joins, as you must pick out only
        the significant bits of your data structure to compute a hash.
        Even if you initialize all fields of your structure, there might be
        alignment padding (holes in the structure) that contain
        garbage values.
       </P
></LI
><LI
><P
>        Most of the internal <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
        types are declared in <TT
CLASS="FILENAME"
>postgres.h</TT
>, while
        the function manager interfaces
        (<TT
CLASS="SYMBOL"
>PG_FUNCTION_ARGS</TT
>, etc.)  are in
        <TT
CLASS="FILENAME"
>fmgr.h</TT
>, so you will need to include at
        least these two files.  For portability reasons it's best to
        include <TT
CLASS="FILENAME"
>postgres.h</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>first</I
></SPAN
>,
        before any other system or user header files.  Including
        <TT
CLASS="FILENAME"
>postgres.h</TT
> will also include
        <TT
CLASS="FILENAME"
>elog.h</TT
> and <TT
CLASS="FILENAME"
>palloc.h</TT
>
        for you.
       </P
></LI
><LI
><P
>        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
       </P
></LI
></UL
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DFUNC"
>35.9.6. Compiling and Linking Dynamically-Loaded Functions</A
></H2
><P
>  Before you are able to use your
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> extension functions written in
  C, they must be compiled and linked in a special way to produce a
  file that can be dynamically loaded by the server.  To be precise, a
  <I
CLASS="FIRSTTERM"
>shared library</I
> needs to be
  created.

 </P
><P
>  For information beyond what is contained in this section
  you should read the documentation of your
  operating system, in particular the manual pages for the C compiler,
  <TT
CLASS="COMMAND"
>cc</TT
>, and the link editor, <TT
CLASS="COMMAND"
>ld</TT
>.
  In addition, the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source code
  contains several working examples in the
  <TT
CLASS="FILENAME"
>contrib</TT
> directory.  If you rely on these
  examples you will make your modules dependent on the availability
  of the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> source code, however.
 </P
><P
>  Creating shared libraries is generally analogous to linking
  executables: first the source files are compiled into object files,
  then the object files are linked together.  The object files need to
  be created as <I
CLASS="FIRSTTERM"
>position-independent code</I
>
  (<ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
>), which
  conceptually means that they can be placed at an arbitrary location
  in memory when they are loaded by the executable.  (Object files
  intended for executables are usually not compiled that way.)  The
  command to link a shared library contains special flags to
  distinguish it from linking an executable (at least in theory
  &mdash; on some systems the practice is much uglier).
 </P
><P
>  In the following examples we assume that your source code is in a
  file <TT
CLASS="FILENAME"
>foo.c</TT
> and we will create a shared library
  <TT
CLASS="FILENAME"
>foo.so</TT
>.  The intermediate object file will be
  called <TT
CLASS="FILENAME"
>foo.o</TT
> unless otherwise noted.  A shared
  library can contain more than one object file, but we only use one
  here.
 </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  The linker flag to create shared
      libraries is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
      This is applicable as of version 4.0 of
      <SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
>.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  To create shared libraries the compiler
      flag is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
      This is applicable as of version 3.0 of
      <SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
></DT
><DD
><P
>      The compiler flag of the system compiler to create
      <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is <TT
CLASS="OPTION"
>+z</TT
>.  When using
      <SPAN
CLASS="APPLICATION"
>GCC</SPAN
> it's <TT
CLASS="OPTION"
>-fpic</TT
>. The
      linker flag for shared libraries is <TT
CLASS="OPTION"
>-b</TT
>.  So:
</P><PRE
CLASS="PROGRAMLISTING"
>cc +z -c foo.c</PRE
><P>
      or:
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c</PRE
><P>
      and then:
</P><PRE
CLASS="PROGRAMLISTING"
>ld -b -o foo.sl foo.o</PRE
><P>
      <SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
> uses the extension
      <TT
CLASS="FILENAME"
>.sl</TT
> for shared libraries, unlike most other
      systems.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>IRIX</SPAN
></DT
><DD
><P
>      <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is the default, no special compiler
      options are necessary.  The linker option to produce shared
      libraries is <TT
CLASS="OPTION"
>-shared</TT
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  On some platforms in some situations
      <TT
CLASS="OPTION"
>-fPIC</TT
> must be used if <TT
CLASS="OPTION"
>-fpic</TT
>
      does not work.  Refer to the GCC manual for more information.
      The compiler flag to create a shared library is
      <TT
CLASS="OPTION"
>-shared</TT
>.  A complete example looks like this:
</P><PRE
CLASS="PROGRAMLISTING"
>cc -fpic -c foo.c
cc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>MacOS X</SPAN
></DT
><DD
><P
>      Here is an example.  It assumes the developer tools are installed.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c 
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  For <ACRONYM
CLASS="ACRONYM"
>ELF</ACRONYM
> systems, the
      compiler with the flag <TT
CLASS="OPTION"
>-shared</TT
> is used to link
      shared libraries.  On the older non-ELF systems, <TT
CLASS="LITERAL"
>ld
      -Bshareable</TT
> is used.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-fpic</TT
>.  <TT
CLASS="LITERAL"
>ld -Bshareable</TT
> is
      used to link shared libraries.
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
ld -Bshareable -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is
      <TT
CLASS="OPTION"
>-KPIC</TT
> with the Sun compiler and
      <TT
CLASS="OPTION"
>-fpic</TT
> with <SPAN
CLASS="APPLICATION"
>GCC</SPAN
>.  To
      link shared libraries, the compiler option is
      <TT
CLASS="OPTION"
>-G</TT
> with either compiler or alternatively
      <TT
CLASS="OPTION"
>-shared</TT
> with <SPAN
CLASS="APPLICATION"
>GCC</SPAN
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -KPIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -G -o foo.so foo.o</PRE
><P>
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Tru64 UNIX</SPAN
></DT
><DD
><P
>      <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is the default, so the compilation command
      is the usual one.  <TT
CLASS="COMMAND"
>ld</TT
> with special options is
      used to do the linking.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -c foo.c
ld -shared -expect_unresolved '*' -o foo.so foo.o</PRE
><P>
      The same procedure is used with GCC instead of the system
      compiler; no special options are required.
     </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
></DT
><DD
><P
>      The compiler flag to create <ACRONYM
CLASS="ACRONYM"
>PIC</ACRONYM
> is <TT
CLASS="OPTION"
>-K
      PIC</TT
> with the SCO compiler and <TT
CLASS="OPTION"
>-fpic</TT
>
      with <SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
>.  To link shared libraries,
      the compiler option is <TT
CLASS="OPTION"
>-G</TT
> with the SCO compiler
      and <TT
CLASS="OPTION"
>-shared</TT
> with
      <SPAN
CLASS="PRODUCTNAME"
>GCC</SPAN
>.
</P><PRE
CLASS="PROGRAMLISTING"
>cc -K PIC -c foo.c
cc -G -o foo.so foo.o</PRE
><P>
      or
</P><PRE
CLASS="PROGRAMLISTING"
>gcc -fpic -c foo.c
gcc -shared -o foo.so foo.o</PRE
><P>
     </P
></DD
></DL
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>   If this is too complicated for you, you should consider using   
   <A
HREF="http://www.gnu.org/software/libtool/"
TARGET="_top"
>   <SPAN
CLASS="PRODUCTNAME"
>GNU Libtool</SPAN
></A
>,
   which hides the platform differences behind a uniform interface.
  </P
></BLOCKQUOTE
></DIV
><P
>  The resulting shared library file can then be loaded into
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>.  When specifying the file name
  to the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command, one must give it
  the name of the shared library file, not the intermediate object file.
  Note that the system's standard shared-library extension (usually
  <TT
CLASS="LITERAL"
>.so</TT
> or <TT
CLASS="LITERAL"
>.sl</TT
>) can be omitted from
  the <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> command, and normally should
  be omitted for best portability.
 </P
><P
>  Refer back to <A
HREF="xfunc-c.html#XFUNC-C-DYNLOAD"
>Section 35.9.1</A
> about where the
  server expects to find the shared library files.
 </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-PGXS"
>35.9.7. Extension Building Infrastructure</A
></H2
><P
>    If you are thinking about distributing your
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> extension modules, setting up a
    portable build system for them can be fairly difficult.  Therefore
    the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> installation provides a build
    infrastructure for extensions, called <ACRONYM
CLASS="ACRONYM"
>PGXS</ACRONYM
>, so
    that simple extension modules can be built simply against an
    already installed server.  Note that this infrastructure is not
    intended to be a universal build system framework that can be used
    to build all software interfacing to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>;
    it simply automates common build rules for simple server extension
    modules.  For more complicated packages, you need to write your
    own build system.
   </P
><P
>    To use the infrastructure for your extension, you must write a
    simple makefile.  In that makefile, you need to set some variables
    and finally include the global <ACRONYM
CLASS="ACRONYM"
>PGXS</ACRONYM
> makefile.
    Here is an example that builds an extension module named
    <TT
CLASS="LITERAL"
>isbn_issn</TT
> consisting of a shared library, an
    SQL script, and a documentation text file:
</P><PRE
CLASS="PROGRAMLISTING"
>MODULES = isbn_issn
DATA_built = isbn_issn.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</PRE
><P>
    The last three lines should always be the same.  Earlier in the
    file, you assign variables or add custom
    <SPAN
CLASS="APPLICATION"
>make</SPAN
> rules.
   </P
><P
>    Set one of these three variables to specify what is built:

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>MODULES</TT
></DT
><DD
><P
>        list of shared objects to be built from source files with same
        stem (do not include suffix in this list)
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>MODULE_big</TT
></DT
><DD
><P
>        a shared object to build from multiple source files
        (list object files in <TT
CLASS="VARNAME"
>OBJS</TT
>)
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PROGRAM</TT
></DT
><DD
><P
>        a binary program to build
        (list object files in <TT
CLASS="VARNAME"
>OBJS</TT
>)
       </P
></DD
></DL
></DIV
><P>

    The following variables can also be set:

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="VARNAME"
>MODULEDIR</TT
></DT
><DD
><P
>        subdirectory into which DATA and DOCS files should be
        installed (if not set, default is <TT
CLASS="LITERAL"
>contrib</TT
>)
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DATA</TT
></DT
><DD
><P
>        random files to install into <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/share/$MODULEDIR</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DATA_built</TT
></DT
><DD
><P
>        random files to install into
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/share/$MODULEDIR</TT
>,
        which need to be built first
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DATA_TSEARCH</TT
></DT
><DD
><P
>        random files to install under
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/share/tsearch_data</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>DOCS</TT
></DT
><DD
><P
>        random files to install under
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/doc/$MODULEDIR</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SCRIPTS</TT
></DT
><DD
><P
>        script files (not binaries) to install into
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/bin</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SCRIPTS_built</TT
></DT
><DD
><P
>        script files (not binaries) to install into
        <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>/bin</TT
>,
        which need to be built first
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>REGRESS</TT
></DT
><DD
><P
>        list of regression test cases (without suffix), see below
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>EXTRA_CLEAN</TT
></DT
><DD
><P
>        extra files to remove in <TT
CLASS="LITERAL"
>make clean</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PG_CPPFLAGS</TT
></DT
><DD
><P
>        will be added to <TT
CLASS="VARNAME"
>CPPFLAGS</TT
>
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PG_LIBS</TT
></DT
><DD
><P
>        will be added to <TT
CLASS="VARNAME"
>PROGRAM</TT
> link line
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>SHLIB_LINK</TT
></DT
><DD
><P
>        will be added to <TT
CLASS="VARNAME"
>MODULE_big</TT
> link line
       </P
></DD
><DT
><TT
CLASS="VARNAME"
>PG_CONFIG</TT
></DT
><DD
><P
>        path to <SPAN
CLASS="APPLICATION"
>pg_config</SPAN
> program for the
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> installation to build against
        (typically just <TT
CLASS="LITERAL"
>pg_config</TT
> to use the first one in your
        <TT
CLASS="VARNAME"
>PATH</TT
>)
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>    Put this makefile as <TT
CLASS="LITERAL"
>Makefile</TT
> in the directory
    which holds your extension. Then you can do
    <TT
CLASS="LITERAL"
>make</TT
> to compile, and later <TT
CLASS="LITERAL"
>make
    install</TT
> to install your module.  By default, the extension is
    compiled and installed for the
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> installation that
    corresponds to the first <TT
CLASS="COMMAND"
>pg_config</TT
> program
    found in your path.  You can use a different installation by
    setting <TT
CLASS="VARNAME"
>PG_CONFIG</TT
> to point to its
    <TT
CLASS="COMMAND"
>pg_config</TT
> program, either within the makefile
    or on the <TT
CLASS="LITERAL"
>make</TT
> command line.
   </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Caution</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>     Changing <TT
CLASS="VARNAME"
>PG_CONFIG</TT
> only works when building
     against <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.3 or later.
     With older releases it does not work to set it to anything except
     <TT
CLASS="LITERAL"
>pg_config</TT
>; you must alter your <TT
CLASS="VARNAME"
>PATH</TT
>
     to select the installation to build against.
    </P
></TD
></TR
></TABLE
></DIV
><P
>    The scripts listed in the <TT
CLASS="VARNAME"
>REGRESS</TT
> variable are used for
    regression testing of your module, just like <TT
CLASS="LITERAL"
>make
    installcheck</TT
> is used for the main
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> server.  For this to work you need
    to have a subdirectory named <TT
CLASS="LITERAL"
>sql/</TT
> in your extension's
    directory, within which you put one file for each group of tests you want
    to run.  The files should have extension <TT
CLASS="LITERAL"
>.sql</TT
>, which
    should not be included in the <TT
CLASS="VARNAME"
>REGRESS</TT
> list in the
    makefile.  For each test there should be a file containing the expected
    result in a subdirectory named <TT
CLASS="LITERAL"
>expected/</TT
>, with extension
    <TT
CLASS="LITERAL"
>.out</TT
>.  The tests are run by executing <TT
CLASS="LITERAL"
>make
    installcheck</TT
>, and the resulting output will be compared to the
    expected files.  The differences will be written to the file
    <TT
CLASS="LITERAL"
>regression.diffs</TT
> in <TT
CLASS="COMMAND"
>diff -c</TT
> format.
    Note that trying to run a test which is missing the expected file will be
    reported as <SPAN
CLASS="QUOTE"
>"trouble"</SPAN
>, so make sure you have all expected
    files.
   </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>     The easiest way of creating the expected files is creating empty files,
     then carefully inspecting the result files after a test run (to be found
     in the <TT
CLASS="LITERAL"
>results/</TT
> directory), and copying them to
     <TT
CLASS="LITERAL"
>expected/</TT
> if they match what you want from the test.
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47190"
>35.9.8. Composite-Type Arguments</A
></H2
><P
>     Composite types do not have a fixed layout like C structures.
     Instances of a composite type can contain null fields.  In
     addition, composite types that are part of an inheritance
     hierarchy can have different fields than other members of the
     same inheritance hierarchy.  Therefore,
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> provides a function
     interface for accessing fields of composite types from C.
    </P
><P
>     Suppose we want to write a function to answer the query:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';</PRE
><P>

     Using call conventions version 0, we can define
     <CODE
CLASS="FUNCTION"
>c_overpaid</CODE
> as:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

bool
c_overpaid(HeapTupleHeader t, /* the current row of emp */
           int32 limit)
{
    bool isnull;
    int32 salary;

    salary = DatumGetInt32(GetAttributeByName(t, "salary", &#38;isnull));
    if (isnull)
        return false;
    return salary &#62; limit;
}</PRE
><P>

     In version-1 coding, the above would look like this:

</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &#38;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */

    PG_RETURN_BOOL(DatumGetInt32(salary) &#62; limit);
}</PRE
><P>
    </P
><P
>     <CODE
CLASS="FUNCTION"
>GetAttributeByName</CODE
> is the
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> system function that
     returns attributes out of the specified row.  It has
     three arguments: the argument of type <TT
CLASS="TYPE"
>HeapTupleHeader</TT
> passed
     into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <CODE
CLASS="FUNCTION"
>GetAttributeByName</CODE
> returns a <TT
CLASS="TYPE"
>Datum</TT
>
     value that you can convert to the proper data type by using the
     appropriate <CODE
CLASS="FUNCTION"
>DatumGet<TT
CLASS="REPLACEABLE"
><I
>XXX</I
></TT
>()</CODE
>
     macro.  Note that the return value is meaningless if the null flag is
     set; always check the null flag before trying to do anything with the
     result.
    </P
><P
>     There is also <CODE
CLASS="FUNCTION"
>GetAttributeByNum</CODE
>, which selects
     the target attribute by column number instead of name.
    </P
><P
>     The following command declares the function
     <CODE
CLASS="FUNCTION"
>c_overpaid</CODE
> in SQL:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;</PRE
><P>

     Notice we have used <TT
CLASS="LITERAL"
>STRICT</TT
> so that we did not have to
     check whether the input arguments were NULL.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47214"
>35.9.9. Returning Rows (Composite Types)</A
></H2
><P
>     To return a row or composite-type value from a C-language
     function, you can use a special API that provides macros and
     functions to hide most of the complexity of building composite
     data types.  To use this API, the source file must include:
</P><PRE
CLASS="PROGRAMLISTING"
>#include "funcapi.h"</PRE
><P>
    </P
><P
>     There are two ways you can build a composite data value (henceforth
     a <SPAN
CLASS="QUOTE"
>"tuple"</SPAN
>): you can build it from an array of Datum values,
     or from an array of C strings that can be passed to the input
     conversion functions of the tuple's column data types.  In either
     case, you first need to obtain or construct a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>
     descriptor for the tuple structure.  When working with Datums, you
     pass the <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> to <CODE
CLASS="FUNCTION"
>BlessTupleDesc</CODE
>,
     and then call <CODE
CLASS="FUNCTION"
>heap_form_tuple</CODE
> for each row.  When working
     with C strings, you pass the <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> to
     <CODE
CLASS="FUNCTION"
>TupleDescGetAttInMetadata</CODE
>, and then call
     <CODE
CLASS="FUNCTION"
>BuildTupleFromCStrings</CODE
> for each row.  In the case of a
     function returning a set of tuples, the setup steps can all be done
     once during the first call of the function.
    </P
><P
>     Several helper functions are available for setting up the needed
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>.  The recommended way to do this in most
     functions returning composite values is to call:
</P><PRE
CLASS="PROGRAMLISTING"
>TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</PRE
><P>
     passing the same <TT
CLASS="LITERAL"
>fcinfo</TT
> struct passed to the calling function
     itself.  (This of course requires that you use the version-1
     calling conventions.)  <TT
CLASS="VARNAME"
>resultTypeId</TT
> can be specified
     as <TT
CLASS="LITERAL"
>NULL</TT
> or as the address of a local variable to receive the
     function's result type OID.  <TT
CLASS="VARNAME"
>resultTupleDesc</TT
> should be the
     address of a local <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> variable.  Check that the
     result is <TT
CLASS="LITERAL"
>TYPEFUNC_COMPOSITE</TT
>; if so,
     <TT
CLASS="VARNAME"
>resultTupleDesc</TT
> has been filled with the needed
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>.  (If it is not, you can report an error along
     the lines of <SPAN
CLASS="QUOTE"
>"function returning record called in context that
     cannot accept type record"</SPAN
>.)
    </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>      <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
> can resolve the actual type of a
      polymorphic function result; so it is useful in functions that return
      scalar polymorphic results, not only functions that return composites.
      The <TT
CLASS="VARNAME"
>resultTypeId</TT
> output is primarily useful for functions
      returning polymorphic scalars.
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
> has a sibling
      <CODE
CLASS="FUNCTION"
>get_expr_result_type</CODE
>, which can be used to resolve the
      expected output type for a function call represented by an expression
      tree.  This can be used when trying to determine the result type from
      outside the function itself.  There is also
      <CODE
CLASS="FUNCTION"
>get_func_result_type</CODE
>, which can be used when only the
      function's OID is available.  However these functions are not able
      to deal with functions declared to return <TT
CLASS="STRUCTNAME"
>record</TT
>, and
      <CODE
CLASS="FUNCTION"
>get_func_result_type</CODE
> cannot resolve polymorphic types,
      so you should preferentially use <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
>.
     </P
></BLOCKQUOTE
></DIV
><P
>     Older, now-deprecated functions for obtaining
     <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>s are:
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc RelationNameGetTupleDesc(const char *relname)</PRE
><P>
     to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> for the row type of a named relation,
     and:
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</PRE
><P>
     to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> based on a type OID. This can
     be used to get a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
> for a base or
     composite type.  It will not work for a function that returns
     <TT
CLASS="STRUCTNAME"
>record</TT
>, however, and it cannot resolve polymorphic
     types.
    </P
><P
>     Once you have a <TT
CLASS="STRUCTNAME"
>TupleDesc</TT
>, call:
</P><PRE
CLASS="PROGRAMLISTING"
>TupleDesc BlessTupleDesc(TupleDesc tupdesc)</PRE
><P>
     if you plan to work with Datums, or:
</P><PRE
CLASS="PROGRAMLISTING"
>AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</PRE
><P>
     if you plan to work with C strings.  If you are writing a function
     returning set, you can save the results of these functions in the
     <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> structure &mdash; use the
     <TT
CLASS="STRUCTFIELD"
>tuple_desc</TT
> or <TT
CLASS="STRUCTFIELD"
>attinmeta</TT
> field
     respectively.
    </P
><P
>     When working with Datums, use:
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)</PRE
><P>
     to build a <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
> given user data in Datum form.
    </P
><P
>     When working with C strings, use:
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</PRE
><P>
     to build a <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
> given user data
     in C string form.  <TT
CLASS="LITERAL"
>values</TT
> is an array of C strings,
     one for each attribute of the return row. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <TT
CLASS="PARAMETER"
>values</TT
> array
     should be set to <TT
CLASS="SYMBOL"
>NULL</TT
>.  This function will need to
     be called again for each row you return.
    </P
><P
>     Once you have built a tuple to return from your function, it
     must be converted into a <TT
CLASS="TYPE"
>Datum</TT
>. Use:
</P><PRE
CLASS="PROGRAMLISTING"
>HeapTupleGetDatum(HeapTuple tuple)</PRE
><P>
     to convert a <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
> into a valid Datum.  This
     <TT
CLASS="TYPE"
>Datum</TT
> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
    </P
><P
>     An example appears in the next section.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XFUNC-C-RETURN-SET"
>35.9.10. Returning Sets</A
></H2
><P
>     There is also a special API that provides support for returning
     sets (multiple rows) from a C-language function.  A set-returning
     function must follow the version-1 calling conventions.  Also,
     source files must include <TT
CLASS="FILENAME"
>funcapi.h</TT
>, as
     above.
    </P
><P
>     A set-returning function (<ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>) is called
     once for each item it returns.  The <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
> must
     therefore save enough state to remember what it was doing and
     return the next item on each call.
     The structure <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
> is provided to help
     control this process.  Within a function, <TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo-&gt;fn_extra</TT
>
     is used to hold a pointer to <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     across calls.
</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct
{
    /*
     * Number of times we've been called before
     *
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint32 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint32 max_calls;

    /*
     * OPTIONAL pointer to result slot
     *
     * This is obsolete and only present for backwards compatibility, viz,
     * user-defined SRFs that use the deprecated TupleDescGetSlot().
     */
    TupleTableSlot *slot;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * OPTIONAL pointer to struct containing tuple description
     *
     * tuple_desc is for use when returning tuples (i.e., composite data types)
     * and is only needed if you are going to build the tuples with
     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
     * the TupleDesc pointer stored here should usually have been run through
     * BlessTupleDesc() first.
     */
    TupleDesc tuple_desc;

} FuncCallContext;</PRE
><P>
    </P
><P
>     An <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
> uses several functions and macros that
     automatically manipulate the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     structure (and expect to find it via <TT
CLASS="LITERAL"
>fn_extra</TT
>).  Use:
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_IS_FIRSTCALL()</PRE
><P>
     to determine if your function is being called for the first or a
     subsequent time. On the first call (only) use:
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_FIRSTCALL_INIT()</PRE
><P>
     to initialize the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>. On every function call,
     including the first, use:
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_PERCALL_SETUP()</PRE
><P>
     to properly set up for using the <TT
CLASS="STRUCTNAME"
>FuncCallContext</TT
>
     and clearing any previously returned data left over from the
     previous pass.
    </P
><P
>     If your function has data to return, use:
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_NEXT(funcctx, result)</PRE
><P>
     to return it to the caller.  (<TT
CLASS="LITERAL"
>result</TT
> must be of type
     <TT
CLASS="TYPE"
>Datum</TT
>, either a single value or a tuple prepared as
     described above.)  Finally, when your function is finished
     returning data, use:
</P><PRE
CLASS="PROGRAMLISTING"
>SRF_RETURN_DONE(funcctx)</PRE
><P>
     to clean up and end the <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
>.
    </P
><P
>     The memory context that is current when the <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to call <CODE
CLASS="FUNCTION"
>pfree</CODE
> on everything
     you allocated using <CODE
CLASS="FUNCTION"
>palloc</CODE
>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
> is a suitable location for any
     data that needs to survive until the <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
> is finished running.  In most
     cases, this means that you should switch into
     <TT
CLASS="STRUCTFIELD"
>multi_call_memory_ctx</TT
> while doing the first-call setup.
    </P
><P
>     A complete pseudo-code example looks like the following:
</P><PRE
CLASS="PROGRAMLISTING"
>Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <TT
CLASS="REPLACEABLE"
><I
>further declarations as needed</I
></TT
>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>if returning composite</I
></TT
>
            <TT
CLASS="REPLACEABLE"
><I
>build TupleDesc, and perhaps AttInMetadata</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>endif returning composite</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
    funcctx = SRF_PERCALL_SETUP();
    <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        <TT
CLASS="REPLACEABLE"
><I
>obtain result Datum</I
></TT
>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items and just need to clean up: */
        <TT
CLASS="REPLACEABLE"
><I
>user code</I
></TT
>
        SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>
    </P
><P
>     A complete example of a simple <ACRONYM
CLASS="ACRONYM"
>SRF</ACRONYM
> returning a composite type
     looks like:
</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* stuff done only on the first call of the function */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx-&#62;multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx-&#62;max_calls = PG_GETARG_UINT32(0);

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &#38;tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&#62;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&#62;call_cntr;
    max_calls = funcctx-&#62;max_calls;
    attinmeta = funcctx-&#62;attinmeta;

    if (call_cntr &#60; max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}</PRE
><P>

     One way to declare this function in SQL is:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     A different way is to use OUT parameters:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</PRE
><P>
     Notice that in this method the output type of the function is formally
     an anonymous <TT
CLASS="STRUCTNAME"
>record</TT
> type.
    </P
><P
>     The directory <TT
CLASS="FILENAME"
>contrib/tablefunc</TT
> in the source
     distribution contains more examples of set-returning functions.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47337"
>35.9.11. Polymorphic Arguments and Return Types</A
></H2
><P
>     C-language functions can be declared to accept and
     return the polymorphic types
     <TT
CLASS="TYPE"
>anyelement</TT
>, <TT
CLASS="TYPE"
>anyarray</TT
>, <TT
CLASS="TYPE"
>anynonarray</TT
>,
     and <TT
CLASS="TYPE"
>anyenum</TT
>.
     See <A
HREF="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC"
>Section 35.2.5</A
> for a more detailed explanation
     of polymorphic functions. When function arguments or return types
     are defined as polymorphic types, the function author cannot know
     in advance what data type it will be called with, or
     need to return. There are two routines provided in <TT
CLASS="FILENAME"
>fmgr.h</TT
>
     to allow a version-1 C function to discover the actual data types
     of its arguments and the type it is expected to return. The routines are
     called <TT
CLASS="LITERAL"
>get_fn_expr_rettype(FmgrInfo *flinfo)</TT
> and
     <TT
CLASS="LITERAL"
>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</TT
>.
     They return the result or argument type OID, or <TT
CLASS="SYMBOL"
>InvalidOid</TT
> if the
     information is not available.
     The structure <TT
CLASS="LITERAL"
>flinfo</TT
> is normally accessed as
     <TT
CLASS="LITERAL"
>fcinfo-&gt;flinfo</TT
>. The parameter <TT
CLASS="LITERAL"
>argnum</TT
>
     is zero based.  <CODE
CLASS="FUNCTION"
>get_call_result_type</CODE
> can also be used
     as an alternative to <CODE
CLASS="FUNCTION"
>get_fn_expr_rettype</CODE
>.
    </P
><P
>     For example, suppose we want to write a function to accept a single
     element of any type, and return a one-dimensional array of that type:

</P><PRE
CLASS="PROGRAMLISTING"
>PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element, being careful in case it's NULL */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</PRE
><P>
    </P
><P
>     The following command declares the function
     <CODE
CLASS="FUNCTION"
>make_array</CODE
> in SQL:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<TT
CLASS="REPLACEABLE"
><I
>DIRECTORY</I
></TT
>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;</PRE
><P>
    </P
><P
>     There is a variant of polymorphism that is only available to C-language
     functions: they can be declared to take parameters of type
     <TT
CLASS="LITERAL"
>"any"</TT
>.  (Note that this type name must be double-quoted,
     since it's also a SQL reserved word.)  This works like
     <TT
CLASS="TYPE"
>anyelement</TT
> except that it does not constrain different
     <TT
CLASS="LITERAL"
>"any"</TT
> arguments to be the same type, nor do they help
     determine the function's result type.  A C-language function can also
     declare its final parameter to be <TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>.  This will
     match one or more actual arguments of any type (not necessarily the same
     type).  These arguments will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> be gathered into an array
     as happens with normal variadic functions; they will just be passed to
     the function separately.  The <CODE
CLASS="FUNCTION"
>PG_NARGS()</CODE
> macro and the
     methods described above must be used to determine the number of actual
     arguments and their types when using this feature.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN47367"
>35.9.12. Shared Memory and LWLocks</A
></H2
><P
>     Add-ins can reserve LWLocks and an allocation of shared memory on server
     startup.  The add-in's shared library must be preloaded by specifying
     it in
     <A
HREF="runtime-config-resource.html#GUC-SHARED-PRELOAD-LIBRARIES"
>shared_preload_libraries</A
>.
     Shared memory is reserved by calling:
</P><PRE
CLASS="PROGRAMLISTING"
>void RequestAddinShmemSpace(int size)</PRE
><P>
     from your <CODE
CLASS="FUNCTION"
>_PG_init</CODE
> function.
    </P
><P
>     LWLocks are reserved by calling:
</P><PRE
CLASS="PROGRAMLISTING"
>void RequestAddinLWLocks(int n)</PRE
><P>
     from <CODE
CLASS="FUNCTION"
>_PG_init</CODE
>.
    </P
><P
>     To avoid possible race-conditions, each backend should use the LWLock
     <CODE
CLASS="FUNCTION"
>AddinShmemInitLock</CODE
> when connecting to and initializing
     its allocation of shared memory, as shown here:
</P><PRE
CLASS="PROGRAMLISTING"
>static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr-&#62;mylockid = LWLockAssign();
        }
        LWLockRelease(AddinShmemInitLock);
}</PRE
><P>
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-internal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xaggr.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Internal Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>User-Defined Aggregates</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>