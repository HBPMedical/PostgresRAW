<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Date/Time Types</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.0.0 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Data Types"
HREF="datatype.html"><LINK
REL="PREVIOUS"
TITLE="Binary Data Types"
HREF="datatype-binary.html"><LINK
REL="NEXT"
TITLE="Boolean Type"
HREF="datatype-boolean.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2010-09-17T01:31:37"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.0.0 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Binary Data Types"
HREF="datatype-binary.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Data Types"
HREF="datatype.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 8. Data Types</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Data Types"
HREF="datatype.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Boolean Type"
HREF="datatype-boolean.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DATATYPE-DATETIME"
>8.5. Date/Time Types</A
></H1
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> supports the full set of
    <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> date and time types, shown in <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-TABLE"
>Table 8-9</A
>.  The operations available
    on these data types are described in
    <A
HREF="functions-datetime.html"
>Section 9.9</A
>.
   </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-TABLE"
></A
><P
><B
>Table 8-9. Date/Time Types</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Storage Size</TH
><TH
>Description</TH
><TH
>Low Value</TH
><TH
>High Value</TH
><TH
>Resolution</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TYPE"
>timestamp [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] [ without time zone ]</TT
></TD
><TD
>8 bytes</TD
><TD
>both date and time (no time zone)</TD
><TD
>4713 BC</TD
><TD
>294276 AD</TD
><TD
>1 microsecond / 14 digits</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>timestamp [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time zone</TT
></TD
><TD
>8 bytes</TD
><TD
>both date and time, with time zone</TD
><TD
>4713 BC</TD
><TD
>294276 AD</TD
><TD
>1 microsecond / 14 digits</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
>4 bytes</TD
><TD
>date (no time of day)</TD
><TD
>4713 BC</TD
><TD
>5874897 AD</TD
><TD
>1 day</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] [ without time zone ]</TT
></TD
><TD
>8 bytes</TD
><TD
>time of day (no date)</TD
><TD
>00:00:00</TD
><TD
>24:00:00</TD
><TD
>1 microsecond / 14 digits</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time zone</TT
></TD
><TD
>12 bytes</TD
><TD
>times of day only, with time zone</TD
><TD
>00:00:00+1459</TD
><TD
>24:00:00-1459</TD
><TD
>1 microsecond / 14 digits</TD
></TR
><TR
><TD
><TT
CLASS="TYPE"
>interval [ <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
> ] [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ]</TT
></TD
><TD
>12 bytes</TD
><TD
>time interval</TD
><TD
>-178000000 years</TD
><TD
>178000000 years</TD
><TD
>1 microsecond / 14 digits</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     The SQL standard requires that writing just <TT
CLASS="TYPE"
>timestamp</TT
>
     be equivalent to <TT
CLASS="TYPE"
>timestamp without time
     zone</TT
>, and <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> honors that
     behavior.  (Releases prior to 7.3 treated it as <TT
CLASS="TYPE"
>timestamp
     with time zone</TT
>.)
    </P
></BLOCKQUOTE
></DIV
><P
>    <TT
CLASS="TYPE"
>time</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
>, and
    <TT
CLASS="TYPE"
>interval</TT
> accept an optional precision value
    <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> is from 0 to 6 for the
    <TT
CLASS="TYPE"
>timestamp</TT
> and <TT
CLASS="TYPE"
>interval</TT
> types.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>    When <TT
CLASS="TYPE"
>timestamp</TT
> values are stored as eight-byte integers
    (currently the default), microsecond precision is available over
    the full range of values. When <TT
CLASS="TYPE"
>timestamp</TT
> values are
    stored as double precision floating-point numbers instead (a
    deprecated compile-time option), the effective limit of precision
    might be less than 6. <TT
CLASS="TYPE"
>timestamp</TT
> values are stored as
    seconds before or after midnight 2000-01-01.  When
    <TT
CLASS="TYPE"
>timestamp</TT
> values are implemented using floating-point
    numbers, microsecond precision is achieved for dates within a few
    years of 2000-01-01, but the precision degrades for dates further
    away. Note that using floating-point datetimes allows a larger
    range of <TT
CLASS="TYPE"
>timestamp</TT
> values to be represented than
    shown above: from 4713 BC up to 5874897 AD.
   </P
><P
>    The same compile-time option also determines whether
    <TT
CLASS="TYPE"
>time</TT
> and <TT
CLASS="TYPE"
>interval</TT
> values are stored as
    floating-point numbers or eight-byte integers.  In the
    floating-point case, large <TT
CLASS="TYPE"
>interval</TT
> values degrade in
    precision as the size of the interval increases.
   </P
></BLOCKQUOTE
></DIV
><P
>    For the <TT
CLASS="TYPE"
>time</TT
> types, the allowed range of
    <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> is from 0 to 6 when eight-byte integer
    storage is used, or from 0 to 10 when floating-point storage is used.
   </P
><P
>    The <TT
CLASS="TYPE"
>interval</TT
> type has an additional option, which is
    to restrict the set of stored fields by writing one of these phrases:
</P><PRE
CLASS="LITERALLAYOUT"
>YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND</PRE
><P>
    Note that if both <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
> and
    <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> are specified, the
    <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
> must include <TT
CLASS="LITERAL"
>SECOND</TT
>,
    since the precision applies only to the seconds.
   </P
><P
>    The type <TT
CLASS="TYPE"
>time with time zone</TT
> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>time</TT
>, <TT
CLASS="TYPE"
>timestamp without time
    zone</TT
>, and <TT
CLASS="TYPE"
>timestamp with time zone</TT
> should
    provide a complete range of date/time functionality required by
    any application.
   </P
><P
>    The types <TT
CLASS="TYPE"
>abstime</TT
>
    and <TT
CLASS="TYPE"
>reltime</TT
> are lower precision types which are used internally.
    You are discouraged from using these types in
    applications;  these internal types
    might disappear in a future release.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-DATETIME-INPUT"
>8.5.1. Date/Time Input</A
></H2
><P
>     Date and time input is accepted in almost any reasonable format, including
     ISO 8601, <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-compatible, 
     traditional <SPAN
CLASS="PRODUCTNAME"
>POSTGRES</SPAN
>, and others.
     For some formats, ordering of day, month, and year in date input is
     ambiguous and there is support for specifying the expected
     ordering of these fields.  Set the <A
HREF="runtime-config-client.html#GUC-DATESTYLE"
>DateStyle</A
> parameter
     to <TT
CLASS="LITERAL"
>MDY</TT
> to select month-day-year interpretation,
     <TT
CLASS="LITERAL"
>DMY</TT
> to select day-month-year interpretation, or
     <TT
CLASS="LITERAL"
>YMD</TT
> to select year-month-day interpretation.
    </P
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> is more flexible in
     handling date/time input than the
     <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard requires.
     See <A
HREF="datetime-appendix.html"
>Appendix B</A
>
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones. 
    </P
><P
>     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to 
     <A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC"
>Section 4.1.2.7</A
> for more
     information.
     <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> requires the following syntax
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] '<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>'</PRE
><P>
     where <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> is an optional precision
     specification giving the number of
     fractional digits in the seconds field. Precision can be
     specified for <TT
CLASS="TYPE"
>time</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
>, and
     <TT
CLASS="TYPE"
>interval</TT
> types.  The allowed values are mentioned
     above.  If no precision is specified in a constant specification,
     it defaults to the precision of the literal value.
    </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN5330"
>8.5.1.1. Dates</A
></H3
><P
>     <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE"
>Table 8-10</A
> shows some possible
     inputs for the <TT
CLASS="TYPE"
>date</TT
> type.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-DATE-TABLE"
></A
><P
><B
>Table 8-10. Date Input</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Example</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>1999-01-08</TD
><TD
>ISO 8601; January 8 in any mode
         (recommended format)</TD
></TR
><TR
><TD
>January 8, 1999</TD
><TD
>unambiguous in any <TT
CLASS="VARNAME"
>datestyle</TT
> input mode</TD
></TR
><TR
><TD
>1/8/1999</TD
><TD
>January 8 in <TT
CLASS="LITERAL"
>MDY</TT
> mode;
          August 1 in <TT
CLASS="LITERAL"
>DMY</TT
> mode</TD
></TR
><TR
><TD
>1/18/1999</TD
><TD
>January 18 in <TT
CLASS="LITERAL"
>MDY</TT
> mode;
          rejected in other modes</TD
></TR
><TR
><TD
>01/02/03</TD
><TD
>January 2, 2003 in <TT
CLASS="LITERAL"
>MDY</TT
> mode;
          February 1, 2003 in <TT
CLASS="LITERAL"
>DMY</TT
> mode;
          February 3, 2001 in <TT
CLASS="LITERAL"
>YMD</TT
> mode
         </TD
></TR
><TR
><TD
>1999-Jan-08</TD
><TD
>January 8 in any mode</TD
></TR
><TR
><TD
>Jan-08-1999</TD
><TD
>January 8 in any mode</TD
></TR
><TR
><TD
>08-Jan-1999</TD
><TD
>January 8 in any mode</TD
></TR
><TR
><TD
>99-Jan-08</TD
><TD
>January 8 in <TT
CLASS="LITERAL"
>YMD</TT
> mode, else error</TD
></TR
><TR
><TD
>08-Jan-99</TD
><TD
>January 8, except error in <TT
CLASS="LITERAL"
>YMD</TT
> mode</TD
></TR
><TR
><TD
>Jan-08-99</TD
><TD
>January 8, except error in <TT
CLASS="LITERAL"
>YMD</TT
> mode</TD
></TR
><TR
><TD
>19990108</TD
><TD
>ISO 8601; January 8, 1999 in any mode</TD
></TR
><TR
><TD
>990108</TD
><TD
>ISO 8601; January 8, 1999 in any mode</TD
></TR
><TR
><TD
>1999.008</TD
><TD
>year and day of year</TD
></TR
><TR
><TD
>J2451187</TD
><TD
>Julian day</TD
></TR
><TR
><TD
>January 8, 99 BC</TD
><TD
>year 99 BC</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN5403"
>8.5.1.2. Times</A
></H3
><P
>      The time-of-day types are <TT
CLASS="TYPE"
>time [
      (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] without time zone</TT
> and
      <TT
CLASS="TYPE"
>time [ (<TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
>) ] with time
      zone</TT
>.  <TT
CLASS="TYPE"
>time</TT
> alone is equivalent to
      <TT
CLASS="TYPE"
>time without time zone</TT
>.
     </P
><P
>      Valid input for these types consists of a time of day followed
      by an optional time zone. (See <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-TIME-TABLE"
>Table 8-11</A
> 
      and <A
HREF="datatype-datetime.html#DATATYPE-TIMEZONE-TABLE"
>Table 8-12</A
>.)  If a time zone is
      specified in the input for <TT
CLASS="TYPE"
>time without time zone</TT
>,
      it is silently ignored. You can also specify a date but it will
      be ignored, except when you use a time zone name that involves a
      daylight-savings rule, such as
      <TT
CLASS="LITERAL"
>America/New_York</TT
>. In this case specifying the date
      is required in order to determine whether standard or daylight-savings
      time applies.  The appropriate time zone offset is recorded in the
      <TT
CLASS="TYPE"
>time with time zone</TT
> value.
     </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-TIME-TABLE"
></A
><P
><B
>Table 8-11. Time Input</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Example</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>04:05:06.789</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05:06</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>040506</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05 AM</TT
></TD
><TD
>same as 04:05; AM does not affect value</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05 PM</TT
></TD
><TD
>same as 16:05; input hour must be &lt;= 12</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05:06.789-8</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05:06-08:00</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05-08:00</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>040506-08</TT
></TD
><TD
>ISO 8601</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>04:05:06 PST</TT
></TD
><TD
>time zone specified by abbreviation</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>2003-04-12 04:05:06 America/New_York</TT
></TD
><TD
>time zone specified by full name</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-TIMEZONE-TABLE"
></A
><P
><B
>Table 8-12. Time Zone Input</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Example</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>PST</TT
></TD
><TD
>Abbreviation (for Pacific Standard Time)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>America/New_York</TT
></TD
><TD
>Full time zone name</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>PST8PDT</TT
></TD
><TD
>POSIX-style time zone specification</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-8:00</TT
></TD
><TD
>ISO-8601 offset for PST</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-800</TT
></TD
><TD
>ISO-8601 offset for PST</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-8</TT
></TD
><TD
>ISO-8601 offset for PST</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>zulu</TT
></TD
><TD
>Military abbreviation for UTC</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>z</TT
></TD
><TD
>Short form of <TT
CLASS="LITERAL"
>zulu</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>     Refer to <A
HREF="datatype-datetime.html#DATATYPE-TIMEZONES"
>Section 8.5.3</A
> for more information on how
     to specify time zones.
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN5523"
>8.5.1.3. Time Stamps</A
></H3
><P
>      Valid input for the time stamp types consists of the concatenation
      of a date and a time, followed by an optional time zone,
      followed by an optional <TT
CLASS="LITERAL"
>AD</TT
> or <TT
CLASS="LITERAL"
>BC</TT
>.
      (Alternatively, <TT
CLASS="LITERAL"
>AD</TT
>/<TT
CLASS="LITERAL"
>BC</TT
> can appear
      before the time zone, but this is not the preferred ordering.)
      Thus:

</P><PRE
CLASS="PROGRAMLISTING"
>1999-01-08 04:05:06</PRE
><P>
      and:
</P><PRE
CLASS="PROGRAMLISTING"
>1999-01-08 04:05:06 -8:00</PRE
><P>

      are valid values, which follow the <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> 8601
      standard.  In addition, the common format:
</P><PRE
CLASS="PROGRAMLISTING"
>January 8 04:05:06 1999 PST</PRE
><P>
      is supported.
     </P
><P
>      The <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard differentiates
      <TT
CLASS="TYPE"
>timestamp without time zone</TT
> 
      and <TT
CLASS="TYPE"
>timestamp with time zone</TT
> literals by the presence of a 
      <SPAN
CLASS="QUOTE"
>"+"</SPAN
> or <SPAN
CLASS="QUOTE"
>"-"</SPAN
> symbol and time zone offset after
      the time.  Hence, according to the standard,

      </P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP '2004-10-19 10:23:54'</PRE
><P>

      is a <TT
CLASS="TYPE"
>timestamp without time zone</TT
>, while

      </P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP '2004-10-19 10:23:54+02'</PRE
><P>

      is a <TT
CLASS="TYPE"
>timestamp with time zone</TT
>.
      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> never examines the content of a
      literal string before determining its type, and therefore will treat
      both of the above as <TT
CLASS="TYPE"
>timestamp without time zone</TT
>.  To
      ensure that a literal is treated as <TT
CLASS="TYPE"
>timestamp with time
      zone</TT
>, give it the correct explicit type:

      </P><PRE
CLASS="PROGRAMLISTING"
>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</PRE
><P>

      In a literal that has been determined to be <TT
CLASS="TYPE"
>timestamp without time
      zone</TT
>, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> will silently ignore
      any time zone indication.
      That is, the resulting value is derived from the date/time
      fields in the input value, and is not adjusted for time zone.
     </P
><P
>      For <TT
CLASS="TYPE"
>timestamp with time zone</TT
>, the internally stored
      value is always in UTC (Universal
      Coordinated Time, traditionally known as Greenwich Mean Time,
      <ACRONYM
CLASS="ACRONYM"
>GMT</ACRONYM
>).  An input value that has an explicit
      time zone specified is converted to UTC using the appropriate offset
      for that time zone.  If no time zone is stated in the input string,
      then it is assumed to be in the time zone indicated by the system's
      <A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>timezone</A
> parameter, and is converted to UTC using the
      offset for the <TT
CLASS="VARNAME"
>timezone</TT
> zone.
     </P
><P
>      When a <TT
CLASS="TYPE"
>timestamp with time
      zone</TT
> value is output, it is always converted from UTC to the
      current <TT
CLASS="VARNAME"
>timezone</TT
> zone, and displayed as local time in that
      zone.  To see the time in another time zone, either change
      <TT
CLASS="VARNAME"
>timezone</TT
> or use the <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
> construct
      (see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT"
>Section 9.9.3</A
>).
     </P
><P
>      Conversions between <TT
CLASS="TYPE"
>timestamp without time zone</TT
> and
      <TT
CLASS="TYPE"
>timestamp with time zone</TT
> normally assume that the
      <TT
CLASS="TYPE"
>timestamp without time zone</TT
> value should be taken or given
      as <TT
CLASS="VARNAME"
>timezone</TT
> local time.  A different time zone can
      be specified for the conversion using <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
>.
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN5573"
>8.5.1.4. Special Values</A
></H3
><P
>      <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> supports several
      special date/time input values for convenience, as shown in <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-TABLE"
>Table 8-13</A
>.  The values
      <TT
CLASS="LITERAL"
>infinity</TT
> and <TT
CLASS="LITERAL"
>-infinity</TT
>
      are specially represented inside the system and will be displayed
      unchanged; but the others are simply notational shorthands
      that will be converted to ordinary date/time values when read.
      (In particular, <TT
CLASS="LITERAL"
>now</TT
> and related strings are converted
      to a specific time value as soon as they are read.)
      All of these values need to be enclosed in single quotes when used
      as constants in SQL commands.
     </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-SPECIAL-TABLE"
></A
><P
><B
>Table 8-13. Special Date/Time Inputs</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Input String</TH
><TH
>Valid Types</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>epoch</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>1970-01-01 00:00:00+00 (Unix system time zero)</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>infinity</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>later than all other time stamps</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-infinity</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>earlier than all other time stamps</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>now</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>time</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>current transaction's start time</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>today</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>midnight today</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>tomorrow</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>midnight tomorrow</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yesterday</TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>midnight yesterday</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>allballs</TT
></TD
><TD
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
>00:00:00.00 UTC</TD
></TR
></TBODY
></TABLE
></DIV
><P
>      The following <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-compatible functions can also
      be used to obtain the current time value for the corresponding data
      type:
      <TT
CLASS="LITERAL"
>CURRENT_DATE</TT
>, <TT
CLASS="LITERAL"
>CURRENT_TIME</TT
>, 
      <TT
CLASS="LITERAL"
>CURRENT_TIMESTAMP</TT
>, <TT
CLASS="LITERAL"
>LOCALTIME</TT
>, 
      <TT
CLASS="LITERAL"
>LOCALTIMESTAMP</TT
>.  The latter four accept an 
      optional subsecond precision specification.  (See <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>.)  Note that these are
      SQL functions and are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> recognized in data input strings.
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-DATETIME-OUTPUT"
>8.5.2. Date/Time Output</A
></H2
><P
>     The output format of the date/time types can be set to one of the four
     styles ISO 8601,
     <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> (Ingres), traditional <SPAN
CLASS="PRODUCTNAME"
>POSTGRES</SPAN
>
     (Unix <SPAN
CLASS="APPLICATION"
>date</SPAN
> format), or
     German.  The default
     is the <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> format.  (The
     <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard requires the use of the ISO 8601
     format.  The name of the <SPAN
CLASS="QUOTE"
>"SQL"</SPAN
> output format is a
     historical accident.)  <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT-TABLE"
>Table 8-14</A
> shows examples of each
     output style.  The output of the <TT
CLASS="TYPE"
>date</TT
> and
     <TT
CLASS="TYPE"
>time</TT
> types is of course only the date or time part
     in accordance with the given examples.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-OUTPUT-TABLE"
></A
><P
><B
>Table 8-14. Date/Time Output Styles</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Style Specification</TH
><TH
>Description</TH
><TH
>Example</TH
></TR
></THEAD
><TBODY
><TR
><TD
>ISO</TD
><TD
>ISO 8601/SQL standard</TD
><TD
>1997-12-17 07:37:16-08</TD
></TR
><TR
><TD
>SQL</TD
><TD
>traditional style</TD
><TD
>12/17/1997 07:37:16.00 PST</TD
></TR
><TR
><TD
>POSTGRES</TD
><TD
>original style</TD
><TD
>Wed Dec 17 07:37:16 1997 PST</TD
></TR
><TR
><TD
>German</TD
><TD
>regional style</TD
><TD
>17.12.1997 07:37:16.00 PST</TD
></TR
></TBODY
></TABLE
></DIV
><P
>     In the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> and POSTGRES styles, day appears before
     month if DMY field ordering has been specified, otherwise month appears
     before day.
     (See <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-INPUT"
>Section 8.5.1</A
>
     for how this setting also affects interpretation of input values.)
     <A
HREF="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT2-TABLE"
>Table 8-15</A
> shows an
     example.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-DATETIME-OUTPUT2-TABLE"
></A
><P
><B
>Table 8-15. Date Order Conventions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
><TT
CLASS="VARNAME"
>datestyle</TT
> Setting</TH
><TH
>Input Ordering</TH
><TH
>Example Output</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>SQL, DMY</TT
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>day</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>month</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>year</I
></TT
></TD
><TD
>17/12/1997 15:37:16.00 CET</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>SQL, MDY</TT
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>month</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>day</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>year</I
></TT
></TD
><TD
>12/17/1997 07:37:16.00 PST</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>Postgres, DMY</TT
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>day</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>month</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>year</I
></TT
></TD
><TD
>Wed 17 Dec 07:37:16 1997 PST</TD
></TR
></TBODY
></TABLE
></DIV
><P
>     The date/time styles can be selected by the user using the
     <TT
CLASS="COMMAND"
>SET datestyle</TT
> command, the <A
HREF="runtime-config-client.html#GUC-DATESTYLE"
>DateStyle</A
> parameter in the
     <TT
CLASS="FILENAME"
>postgresql.conf</TT
> configuration file, or the
     <TT
CLASS="ENVAR"
>PGDATESTYLE</TT
> environment variable on the server or
     client.  The formatting function <CODE
CLASS="FUNCTION"
>to_char</CODE
>
     (see <A
HREF="functions-formatting.html"
>Section 9.8</A
>) is also available as
     a more flexible way to format date/time output.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-TIMEZONES"
>8.5.3. Time Zones</A
></H2
><P
>    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900's,
    but continue to be prone to arbitrary changes, particularly with
    respect to daylight-savings rules.
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> uses the widely-used
    <TT
CLASS="LITERAL"
>zoneinfo</TT
> time zone database for information about
    historical time zone rules.  For times in the future, the assumption
    is that the latest known rules for a given time zone will
    continue to be observed indefinitely far into the future.
   </P
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> endeavors to be compatible with
     the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard definitions for typical usage.
     However, the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:

     <P
></P
></P><UL
><LI
><P
>        Although the <TT
CLASS="TYPE"
>date</TT
> type 
        cannot have an associated time zone, the
        <TT
CLASS="TYPE"
>time</TT
> type can.
        Time zones in the real world have little meaning unless 
        associated with a date as well as a time,
        since the offset can vary through the year with daylight-saving
        time boundaries.
       </P
></LI
><LI
><P
>        The default time zone is specified as a constant numeric offset 
        from <ACRONYM
CLASS="ACRONYM"
>UTC</ACRONYM
>. It is therefore impossible to adapt to
        daylight-saving time when doing date/time arithmetic across
        <ACRONYM
CLASS="ACRONYM"
>DST</ACRONYM
> boundaries.
       </P
></LI
></UL
><P>
    </P
><P
>     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     do <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> recommend using the type <TT
CLASS="TYPE"
>time with
     time zone</TT
> (though it is supported by
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> for legacy applications and
     for compliance with the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard).
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> assumes
     your local time zone for any type containing only date or time.
    </P
><P
>     All timezone-aware dates and times are stored internally in
     <ACRONYM
CLASS="ACRONYM"
>UTC</ACRONYM
>.  They are converted to local time
     in the zone specified by the <A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>timezone</A
> configuration
     parameter before being displayed to the client.
    </P
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> allows you to specify time zones in
     three different forms:
     <P
></P
></P><UL
><LI
><P
>        A full time zone name, for example <TT
CLASS="LITERAL"
>America/New_York</TT
>.
        The recognized time zone names are listed in the
        <TT
CLASS="LITERAL"
>pg_timezone_names</TT
> view (see <A
HREF="view-pg-timezone-names.html"
>Section 45.60</A
>).
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> uses the widely-used
        <TT
CLASS="LITERAL"
>zoneinfo</TT
> time zone data for this purpose, so the same
        names are also recognized by much other software.
       </P
></LI
><LI
><P
>        A time zone abbreviation, for example <TT
CLASS="LITERAL"
>PST</TT
>.  Such a
        specification merely defines a particular offset from UTC, in
        contrast to full time zone names which can imply a set of daylight
        savings transition-date rules as well.  The recognized abbreviations
        are listed in the <TT
CLASS="LITERAL"
>pg_timezone_abbrevs</TT
> view (see <A
HREF="view-pg-timezone-abbrevs.html"
>Section 45.59</A
>).  You cannot set the
        configuration parameters <A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>timezone</A
> or
        <A
HREF="runtime-config-logging.html#GUC-LOG-TIMEZONE"
>log_timezone</A
> to a time
        zone abbreviation, but you can use abbreviations in
        date/time input values and with the <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
>
        operator.
       </P
></LI
><LI
><P
>        In addition to the timezone names and abbreviations,
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> will accept POSIX-style time zone
        specifications of the form <TT
CLASS="REPLACEABLE"
><I
>STD</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>offset</I
></TT
> or
        <TT
CLASS="REPLACEABLE"
><I
>STD</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>offset</I
></TT
><TT
CLASS="REPLACEABLE"
><I
>DST</I
></TT
>, where
        <TT
CLASS="REPLACEABLE"
><I
>STD</I
></TT
> is a zone abbreviation, <TT
CLASS="REPLACEABLE"
><I
>offset</I
></TT
> is a
        numeric offset in hours west from UTC, and <TT
CLASS="REPLACEABLE"
><I
>DST</I
></TT
> is an
        optional daylight-savings zone abbreviation, assumed to stand for one
        hour ahead of the given offset. For example, if <TT
CLASS="LITERAL"
>EST5EDT</TT
>
        were not already a recognized zone name, it would be accepted and would
        be functionally equivalent to United States East Coast time.  When a
        daylight-savings zone name is present, it is assumed to be used
        according to the same daylight-savings transition rules used in the
        <TT
CLASS="LITERAL"
>zoneinfo</TT
> time zone database's <TT
CLASS="FILENAME"
>posixrules</TT
> entry.
        In a standard <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> installation,
        <TT
CLASS="FILENAME"
>posixrules</TT
> is the same as <TT
CLASS="LITERAL"
>US/Eastern</TT
>, so
        that POSIX-style time zone specifications follow USA daylight-savings
        rules.  If needed, you can adjust this behavior by replacing the
        <TT
CLASS="FILENAME"
>posixrules</TT
> file.
       </P
></LI
></UL
><P>

     In short, this is the difference between abbreviations
     and full names: abbreviations always represent a fixed offset from
     UTC, whereas most of the full names imply a local daylight-savings time
     rule, and so have two possible UTC offsets.
    </P
><P
>     One should be wary that the POSIX-style time zone feature can
     lead to silently accepting bogus input, since there is no check on the
     reasonableness of the zone abbreviations.  For example, <TT
CLASS="LITERAL"
>SET
     TIMEZONE TO FOOBAR0</TT
> will work, leaving the system effectively using
     a rather peculiar abbreviation for UTC.
     Another issue to keep in mind is that in POSIX time zone names,
     positive offsets are used for locations <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>west</I
></SPAN
> of Greenwich.
     Everywhere else, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> follows the
     ISO-8601 convention that positive timezone offsets are <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>east</I
></SPAN
>
     of Greenwich.
    </P
><P
>     In all cases, timezone names are recognized case-insensitively.
     (This is a change from <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> versions
     prior to 8.2, which were case-sensitive in some contexts but not others.)
    </P
><P
>     Neither full names nor abbreviations are hard-wired into the server;
     they are obtained from configuration files stored under
     <TT
CLASS="FILENAME"
>.../share/timezone/</TT
> and <TT
CLASS="FILENAME"
>.../share/timezonesets/</TT
>
     of the installation directory
     (see <A
HREF="datetime-config-files.html"
>Section B.3</A
>).
    </P
><P
>     The <A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>timezone</A
> configuration parameter can
     be set in the file <TT
CLASS="FILENAME"
>postgresql.conf</TT
>, or in any of the
     other standard ways described in <A
HREF="runtime-config.html"
>Chapter 18</A
>.
     There are also several special ways to set it:

     <P
></P
></P><UL
><LI
><P
>        If <TT
CLASS="VARNAME"
>timezone</TT
> is not specified in
        <TT
CLASS="FILENAME"
>postgresql.conf</TT
> or as a server command-line option,
        the server attempts to use the value of the <TT
CLASS="ENVAR"
>TZ</TT
>
        environment variable as the default time zone.  If <TT
CLASS="ENVAR"
>TZ</TT
>
        is not defined or is not any of the time zone names known to
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, the server attempts to
        determine the operating system's default time zone by checking the
        behavior of the C library function <TT
CLASS="LITERAL"
>localtime()</TT
>.  The
        default time zone is selected as the closest match among
        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s known time zones.
        (These rules are also used to choose the default value of
        <A
HREF="runtime-config-logging.html#GUC-LOG-TIMEZONE"
>log_timezone</A
>, if not specified.)
       </P
></LI
><LI
><P
>        The <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> command <TT
CLASS="COMMAND"
>SET TIME ZONE</TT
>
        sets the time zone for the session.  This is an alternative spelling
        of <TT
CLASS="COMMAND"
>SET TIMEZONE TO</TT
> with a more SQL-spec-compatible syntax.
       </P
></LI
><LI
><P
>        The <TT
CLASS="ENVAR"
>PGTZ</TT
> environment variable is used by
        <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> clients
        to send a <TT
CLASS="COMMAND"
>SET TIME ZONE</TT
>
        command to the server upon connection.
       </P
></LI
></UL
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-INTERVAL-INPUT"
>8.5.4. Interval Input</A
></H2
><P
>      <TT
CLASS="TYPE"
>interval</TT
> values can be written using the following
      verbose syntax:

</P><PRE
CLASS="SYNOPSIS"
>[<SPAN
CLASS="OPTIONAL"
>@</SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
>...</SPAN
>] [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
></SPAN
>]</PRE
><P>

     where <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> is a number (possibly signed);
     <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> is <TT
CLASS="LITERAL"
>microsecond</TT
>,
     <TT
CLASS="LITERAL"
>millisecond</TT
>, <TT
CLASS="LITERAL"
>second</TT
>,
     <TT
CLASS="LITERAL"
>minute</TT
>, <TT
CLASS="LITERAL"
>hour</TT
>, <TT
CLASS="LITERAL"
>day</TT
>,
     <TT
CLASS="LITERAL"
>week</TT
>, <TT
CLASS="LITERAL"
>month</TT
>, <TT
CLASS="LITERAL"
>year</TT
>,
     <TT
CLASS="LITERAL"
>decade</TT
>, <TT
CLASS="LITERAL"
>century</TT
>, <TT
CLASS="LITERAL"
>millennium</TT
>,
     or abbreviations or plurals of these units;
     <TT
CLASS="REPLACEABLE"
><I
>direction</I
></TT
> can be <TT
CLASS="LITERAL"
>ago</TT
> or
     empty.  The at sign (<TT
CLASS="LITERAL"
>@</TT
>) is optional noise.  The amounts
     of the different units are implicitly added with appropriate
     sign accounting.  <TT
CLASS="LITERAL"
>ago</TT
> negates all the fields.
     This syntax is also used for interval output, if
     <A
HREF="runtime-config-client.html#GUC-INTERVALSTYLE"
>IntervalStyle</A
> is set to
     <TT
CLASS="LITERAL"
>postgres_verbose</TT
>.
    </P
><P
>     Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <TT
CLASS="LITERAL"
>'1 12:59:10'</TT
> is read
     the same as <TT
CLASS="LITERAL"
>'1 day 12 hours 59 min 10 sec'</TT
>.  Also,
     a combination of years and months can be specified with a dash;
     for example <TT
CLASS="LITERAL"
>'200-10'</TT
> is read the same as <TT
CLASS="LITERAL"
>'200 years
     10 months'</TT
>.  (These shorter forms are in fact the only ones allowed
     by the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard, and are used for output when
     <TT
CLASS="VARNAME"
>IntervalStyle</TT
> is set to <TT
CLASS="LITERAL"
>sql_standard</TT
>.)
    </P
><P
>     Interval values can also be written as ISO 8601 time intervals, using
     either the <SPAN
CLASS="QUOTE"
>"format with designators"</SPAN
> of the standard's section
     4.4.3.2 or the <SPAN
CLASS="QUOTE"
>"alternative format"</SPAN
> of section 4.4.3.3.  The
     format with designators looks like this:
</P><PRE
CLASS="SYNOPSIS"
>P <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> ...</SPAN
>] [<SPAN
CLASS="OPTIONAL"
> T [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>quantity</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>unit</I
></TT
> ...</SPAN
>]</SPAN
>]</PRE
><P>
      The string must start with a <TT
CLASS="LITERAL"
>P</TT
>, and may include a
      <TT
CLASS="LITERAL"
>T</TT
> that introduces the time-of-day units.  The
      available unit abbreviations are given in <A
HREF="datatype-datetime.html#DATATYPE-INTERVAL-ISO8601-UNITS"
>Table 8-16</A
>.  Units may be
      omitted, and may be specified in any order, but units smaller than
      a day must appear after <TT
CLASS="LITERAL"
>T</TT
>.  In particular, the meaning of
      <TT
CLASS="LITERAL"
>M</TT
> depends on whether it is before or after
      <TT
CLASS="LITERAL"
>T</TT
>.
     </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-INTERVAL-ISO8601-UNITS"
></A
><P
><B
>Table 8-16. ISO 8601 interval unit abbreviations</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Abbreviation</TH
><TH
>Meaning</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Y</TD
><TD
>Years</TD
></TR
><TR
><TD
>M</TD
><TD
>Months (in the date part)</TD
></TR
><TR
><TD
>W</TD
><TD
>Weeks</TD
></TR
><TR
><TD
>D</TD
><TD
>Days</TD
></TR
><TR
><TD
>H</TD
><TD
>Hours</TD
></TR
><TR
><TD
>M</TD
><TD
>Minutes (in the time part)</TD
></TR
><TR
><TD
>S</TD
><TD
>Seconds</TD
></TR
></TBODY
></TABLE
></DIV
><P
>      In the alternative format:
</P><PRE
CLASS="SYNOPSIS"
>P [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>years</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>months</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>days</I
></TT
> </SPAN
>] [<SPAN
CLASS="OPTIONAL"
> T <TT
CLASS="REPLACEABLE"
><I
>hours</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>minutes</I
></TT
>:<TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
> </SPAN
>]</PRE
><P>
      the string must begin with <TT
CLASS="LITERAL"
>P</TT
>, and a
      <TT
CLASS="LITERAL"
>T</TT
> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates.
    </P
><P
>     When writing an interval constant with a <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
>
     specification, or when assigning a string to an interval column that was
     defined with a <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
> specification, the interpretation of
     unmarked quantities depends on the <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
>.  For
     example <TT
CLASS="LITERAL"
>INTERVAL '1' YEAR</TT
> is read as 1 year, whereas
     <TT
CLASS="LITERAL"
>INTERVAL '1'</TT
> means 1 second.  Also, field values
     <SPAN
CLASS="QUOTE"
>"to the right"</SPAN
> of the least significant field allowed by the
     <TT
CLASS="REPLACEABLE"
><I
>fields</I
></TT
> specification are silently discarded.  For
     example, writing <TT
CLASS="LITERAL"
>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</TT
>
     results in dropping the seconds field, but not the day field.
    </P
><P
>     According to the <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> standard all fields of an interval
     value must have the same sign, so a leading negative sign applies to all
     fields; for example the negative sign in the interval literal
     <TT
CLASS="LITERAL"
>'-1 2:03:04'</TT
> applies to both the days and hour/minute/second
     parts.  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> allows the fields to have different
     signs, and traditionally treats each field in the textual representation
     as independently signed, so that the hour/minute/second part is
     considered positive in this example.  If <TT
CLASS="VARNAME"
>IntervalStyle</TT
> is
     set to <TT
CLASS="LITERAL"
>sql_standard</TT
> then a leading sign is considered
     to apply to all fields (but only if no additional signs appear).
     Otherwise the traditional <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> interpretation is
     used.  To avoid ambiguity, it's recommended to attach an explicit sign
     to each field if any field is negative.
    </P
><P
>     Internally <TT
CLASS="TYPE"
>interval</TT
> values are stored as months, days,
     and seconds. This is done because the number of days in a month
     varies, and a day can have 23 or 25 hours if a daylight savings
     time adjustment is involved.  The months and days fields are integers
     while the seconds field can store fractions.  Because intervals are
     usually created from constant strings or <TT
CLASS="TYPE"
>timestamp</TT
> subtraction,
     this storage method works well in most cases. Functions
     <CODE
CLASS="FUNCTION"
>justify_days</CODE
> and <CODE
CLASS="FUNCTION"
>justify_hours</CODE
> are
     available for adjusting days and hours that overflow their normal
     ranges.
    </P
><P
>     In the verbose input format, and in some fields of the more compact
     input formats, field values can have fractional parts; for example
     <TT
CLASS="LITERAL"
>'1.5 week'</TT
> or <TT
CLASS="LITERAL"
>'01:02:03.45'</TT
>.  Such input is
     converted to the appropriate number of months, days, and seconds
     for storage.  When this would result in a fractional number of
     months or days, the fraction is added to the lower-order fields
     using the conversion factors 1 month = 30 days and 1 day = 24 hours.
     For example, <TT
CLASS="LITERAL"
>'1.5 month'</TT
> becomes 1 month and 15 days.
     Only seconds will ever be shown as fractional on output.
    </P
><P
>     <A
HREF="datatype-datetime.html#DATATYPE-INTERVAL-INPUT-EXAMPLES"
>Table 8-17</A
> shows some examples
     of valid <TT
CLASS="TYPE"
>interval</TT
> input.
    </P
><DIV
CLASS="TABLE"
><A
NAME="DATATYPE-INTERVAL-INPUT-EXAMPLES"
></A
><P
><B
>Table 8-17. Interval Input</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Example</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>1-2</TD
><TD
>SQL standard format: 1 year 2 months</TD
></TR
><TR
><TD
>3 4:05:06</TD
><TD
>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</TD
></TR
><TR
><TD
>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</TD
><TD
>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</TD
></TR
><TR
><TD
>P1Y2M3DT4H5M6S</TD
><TD
>ISO 8601 <SPAN
CLASS="QUOTE"
>"format with designators"</SPAN
>: same meaning as above</TD
></TR
><TR
><TD
>P0001-02-03T04:05:06</TD
><TD
>ISO 8601 <SPAN
CLASS="QUOTE"
>"alternative format"</SPAN
>: same meaning as above</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-INTERVAL-OUTPUT"
>8.5.5. Interval Output</A
></H2
><P
>     The output format of the interval type can be set to one of the
     four styles <TT
CLASS="LITERAL"
>sql_standard</TT
>, <TT
CLASS="LITERAL"
>postgres</TT
>,
     <TT
CLASS="LITERAL"
>postgres_verbose</TT
>, or <TT
CLASS="LITERAL"
>iso_8601</TT
>,
     using the command <TT
CLASS="LITERAL"
>SET intervalstyle</TT
>.
     The default is the <TT
CLASS="LITERAL"
>postgres</TT
> format.
     <A
HREF="datatype-datetime.html#INTERVAL-STYLE-OUTPUT-TABLE"
>Table 8-18</A
> shows examples of each
     output style.
    </P
><P
>     The <TT
CLASS="LITERAL"
>sql_standard</TT
> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.
    </P
><P
>     The output of the <TT
CLASS="LITERAL"
>postgres</TT
> style matches the output of
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> releases prior to 8.4 when the
     <A
HREF="runtime-config-client.html#GUC-DATESTYLE"
>DateStyle</A
> parameter was set to <TT
CLASS="LITERAL"
>ISO</TT
>.
    </P
><P
>     The output of the <TT
CLASS="LITERAL"
>postgres_verbose</TT
> style matches the output of
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> releases prior to 8.4 when the
     <TT
CLASS="VARNAME"
>DateStyle</TT
> parameter was set to non-<TT
CLASS="LITERAL"
>ISO</TT
> output.
    </P
><P
>     The output of the <TT
CLASS="LITERAL"
>iso_8601</TT
> style matches the <SPAN
CLASS="QUOTE"
>"format
     with designators"</SPAN
> described in section 4.4.3.2 of the
     ISO 8601 standard.
    </P
><DIV
CLASS="TABLE"
><A
NAME="INTERVAL-STYLE-OUTPUT-TABLE"
></A
><P
><B
>Table 8-18. Interval Output Style Examples</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>Style Specification</TH
><TH
>Year-Month Interval</TH
><TH
>Day-Time Interval</TH
><TH
>Mixed Interval</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>sql_standard</TT
></TD
><TD
>1-2</TD
><TD
>3 4:05:06</TD
><TD
>-1-2 +3 -4:05:06</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>postgres</TT
></TD
><TD
>1 year 2 mons</TD
><TD
>3 days 04:05:06</TD
><TD
>-1 year -2 mons +3 days -04:05:06</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>postgres_verbose</TT
></TD
><TD
>@ 1 year 2 mons</TD
><TD
>@ 3 days 4 hours 5 mins 6 secs</TD
><TD
>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>iso_8601</TT
></TD
><TD
>P1Y2M</TD
><TD
>P3DT4H5M6S</TD
><TD
>P-1Y-2M3DT-4H-5M-6S</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="DATATYPE-DATETIME-INTERNALS"
>8.5.6. Internals</A
></H2
><P
>     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> uses Julian dates
     for all date/time calculations. This has the useful property of correctly
     calculating dates from 4713 BC
     to far into the future, using the assumption that the length of the
     year is 365.2425 days.
    </P
><P
>     Date conventions before the 19th century make for interesting reading,
     but are not consistent enough to warrant coding into a date/time handler.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="datatype-binary.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="datatype-boolean.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Binary Data Types</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="datatype.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Boolean Type</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>