<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Date/Time Functions and Operators</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.0.0 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Functions and Operators"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="Data Type Formatting Functions"
HREF="functions-formatting.html"><LINK
REL="NEXT"
TITLE="Enum Support Functions"
HREF="functions-enum.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2010-09-17T01:31:37"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.0.0 Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Data Type Formatting Functions"
HREF="functions-formatting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Functions and Operators"
HREF="functions.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Functions and Operators</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Functions and Operators"
HREF="functions.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Enum Support Functions"
HREF="functions-enum.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-DATETIME"
>9.9. Date/Time Functions and Operators</A
></H1
><P
>   <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-TABLE"
>Table 9-27</A
> shows the available
   functions for date/time value processing, with details appearing in
   the following subsections.  <A
HREF="functions-datetime.html#OPERATORS-DATETIME-TABLE"
>Table 9-26</A
> illustrates the behaviors of
   the basic arithmetic operators (<TT
CLASS="LITERAL"
>+</TT
>,
   <TT
CLASS="LITERAL"
>*</TT
>, etc.).  For formatting functions, refer to
   <A
HREF="functions-formatting.html"
>Section 9.8</A
>.  You should be familiar with
   the background information on date/time data types from <A
HREF="datatype-datetime.html"
>Section 8.5</A
>.
  </P
><P
>   All the functions and operators described below that take <TT
CLASS="TYPE"
>time</TT
> or <TT
CLASS="TYPE"
>timestamp</TT
>
   inputs actually come in two variants: one that takes <TT
CLASS="TYPE"
>time with time zone</TT
> or <TT
CLASS="TYPE"
>timestamp
   with time zone</TT
>, and one that takes <TT
CLASS="TYPE"
>time without time zone</TT
> or <TT
CLASS="TYPE"
>timestamp without time zone</TT
>.
   For brevity, these variants are not shown separately.  Also, the
   <TT
CLASS="LITERAL"
>+</TT
> and <TT
CLASS="LITERAL"
>*</TT
> operators come in commutative pairs (for
   example both date + integer and integer + date); we show only one of each
   such pair.
  </P
><DIV
CLASS="TABLE"
><A
NAME="OPERATORS-DATETIME-TABLE"
></A
><P
><B
>Table 9-26. Date/Time Operators</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Operator</TH
><TH
>Example</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-09-28' + integer '7'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>date '2001-10-05'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-09-28' + interval '1 hour'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-28 01:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-09-28' + time '03:00'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-28 03:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>interval '1 day' + interval '1 hour'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '1 day 01:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-28 01:00' + interval '23 hours'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-29 00:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>+</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>time '01:00' + interval '3 hours'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>time '04:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>- interval '23 hours'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '-23:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-10-01' - date '2001-09-28'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>integer '3'</TT
> (days)</TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-10-01' - integer '7'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>date '2001-09-24'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>date '2001-09-28' - interval '1 hour'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-27 23:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>time '05:00' - time '03:00'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '02:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>time '05:00' - interval '2 hours'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>time '03:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-28 23:00' - interval '23 hours'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-28 00:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>interval '1 day' - interval '1 hour'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '1 day -01:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>-</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '1 day 15:00:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>*</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>900 * interval '1 second'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '00:15:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>*</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>21 * interval '1 day'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '21 days'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>*</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>double precision '3.5' * interval '1 hour'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '03:30:00'</TT
></TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>/</TT
> </TD
><TD
><TT
CLASS="LITERAL"
>interval '1 hour' / double precision '1.5'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>interval '00:40:00'</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-DATETIME-TABLE"
></A
><P
><B
>Table 9-27. Date/Time Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>Function</TH
><TH
>Return Type</TH
><TH
>Description</TH
><TH
>Example</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>age(<TT
CLASS="TYPE"
>timestamp</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
>Subtract arguments, producing a <SPAN
CLASS="QUOTE"
>"symbolic"</SPAN
> result that
        uses years and months</TD
><TD
><TT
CLASS="LITERAL"
>age(timestamp '2001-04-10', timestamp '1957-06-13')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>43 years 9 mons 27 days</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>age(<TT
CLASS="TYPE"
>timestamp</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
>Subtract from <CODE
CLASS="FUNCTION"
>current_date</CODE
> (at midnight)</TD
><TD
><TT
CLASS="LITERAL"
>age(timestamp '1957-06-13')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>43 years 8 mons 3 days</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>clock_timestamp()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Current date and time (changes during statement execution);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_date</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>date</TT
></TD
><TD
>Current date;
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_time</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
>Current time of day;
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_timestamp</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Current date and time (start of current transaction);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>date_part(<TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>Get subfield (equivalent to <CODE
CLASS="FUNCTION"
>extract</CODE
>);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT"
>Section 9.9.1</A
>
        </TD
><TD
><TT
CLASS="LITERAL"
>date_part('hour', timestamp '2001-02-16 20:38:40')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>20</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>date_part(<TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>interval</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>Get subfield (equivalent to
         <CODE
CLASS="FUNCTION"
>extract</CODE
>); see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT"
>Section 9.9.1</A
>
        </TD
><TD
><TT
CLASS="LITERAL"
>date_part('month', interval '2 years 3 months')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>date_trunc(<TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>timestamp</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>Truncate to specified precision; see also <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-TRUNC"
>Section 9.9.2</A
>
        </TD
><TD
><TT
CLASS="LITERAL"
>date_trunc('hour', timestamp '2001-02-16 20:38:40')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2001-02-16 20:00:00</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>extract</CODE
>(<TT
CLASS="PARAMETER"
>field</TT
> from
         <TT
CLASS="TYPE"
>timestamp</TT
>)</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>Get subfield; see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT"
>Section 9.9.1</A
>
        </TD
><TD
><TT
CLASS="LITERAL"
>extract(hour from timestamp '2001-02-16 20:38:40')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>20</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>extract</CODE
>(<TT
CLASS="PARAMETER"
>field</TT
> from
         <TT
CLASS="TYPE"
>interval</TT
>)</TT
></TD
><TD
><TT
CLASS="TYPE"
>double precision</TT
></TD
><TD
>Get subfield; see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-EXTRACT"
>Section 9.9.1</A
>
        </TD
><TD
><TT
CLASS="LITERAL"
>extract(month from interval '2 years 3 months')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>isfinite(<TT
CLASS="TYPE"
>date</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>Test for finite date (not +/-infinity)</TD
><TD
><TT
CLASS="LITERAL"
>isfinite(date '2001-02-16')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>true</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>isfinite(<TT
CLASS="TYPE"
>timestamp</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>Test for finite time stamp (not +/-infinity)</TD
><TD
><TT
CLASS="LITERAL"
>isfinite(timestamp '2001-02-16 21:28:30')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>true</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>isfinite(<TT
CLASS="TYPE"
>interval</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>Test for finite interval</TD
><TD
><TT
CLASS="LITERAL"
>isfinite(interval '4 hours')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>true</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>justify_days(<TT
CLASS="TYPE"
>interval</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
>Adjust interval so 30-day time periods are represented as months</TD
><TD
><TT
CLASS="LITERAL"
>justify_days(interval '35 days')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1 mon 5 days</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>justify_hours(<TT
CLASS="TYPE"
>interval</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
>Adjust interval so 24-hour time periods are represented as days</TD
><TD
><TT
CLASS="LITERAL"
>justify_hours(interval '27 hours')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1 day 03:00:00</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>justify_interval(<TT
CLASS="TYPE"
>interval</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>interval</TT
></TD
><TD
>Adjust interval using <CODE
CLASS="FUNCTION"
>justify_days</CODE
> and <CODE
CLASS="FUNCTION"
>justify_hours</CODE
>, with additional sign adjustments</TD
><TD
><TT
CLASS="LITERAL"
>justify_interval(interval '1 mon -1 hour')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>29 days 23:00:00</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>localtime</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>time</TT
></TD
><TD
>Current time of day;
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>localtimestamp</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp</TT
></TD
><TD
>Current date and time (start of current transaction);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>now()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Current date and time (start of current transaction);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>statement_timestamp()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Current date and time (start of current statement);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>timeofday()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>Current date and time
         (like <CODE
CLASS="FUNCTION"
>clock_timestamp</CODE
>, but as a <TT
CLASS="TYPE"
>text</TT
> string);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>transaction_timestamp()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Current date and time (start of current transaction);
         see <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
>Section 9.9.4</A
>
        </TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    In addition to these functions, the SQL <TT
CLASS="LITERAL"
>OVERLAPS</TT
> operator is
    supported:
</P><PRE
CLASS="SYNOPSIS"
>(<TT
CLASS="REPLACEABLE"
><I
>start1</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>end1</I
></TT
>) OVERLAPS (<TT
CLASS="REPLACEABLE"
><I
>start2</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>end2</I
></TT
>)
(<TT
CLASS="REPLACEABLE"
><I
>start1</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>length1</I
></TT
>) OVERLAPS (<TT
CLASS="REPLACEABLE"
><I
>start2</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>length2</I
></TT
>)</PRE
><P>
    This expression yields true when two time periods (defined by their
    endpoints) overlap, false when they do not overlap.  The endpoints
    can be specified as pairs of dates, times, or time stamps; or as
    a date, time, or time stamp followed by an interval.  When a pair
    of values is provided, either the start or the end can be written
    first; <TT
CLASS="LITERAL"
>OVERLAPS</TT
> automatically takes the earlier value
    of the pair as the start.  Each time period is considered to
    represent the half-open interval <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> <TT
CLASS="LITERAL"
>&lt;=</TT
>
    <TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
> <TT
CLASS="LITERAL"
>&lt;</TT
> <TT
CLASS="REPLACEABLE"
><I
>end</I
></TT
>, unless
    <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> and <TT
CLASS="REPLACEABLE"
><I
>end</I
></TT
> are equal in which case it
    represents that single time instant.  This means for instance that two
    time periods with only an endpoint in common do not overlap.
   </P
><PRE
CLASS="SCREEN"
>SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>true</SAMP
>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>false</SAMP
>
SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>false</SAMP
>
SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS
       (DATE '2001-10-30', DATE '2001-10-31');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>true</SAMP
></PRE
><P
>   When adding an <TT
CLASS="TYPE"
>interval</TT
> value to (or subtracting an 
   <TT
CLASS="TYPE"
>interval</TT
> value from) a <TT
CLASS="TYPE"
>timestamp with time zone</TT
> 
   value, the days component advances (or decrements) the date of the 
   <TT
CLASS="TYPE"
>timestamp with time zone</TT
> by the indicated number of days. 
   Across daylight saving time changes (with the session time zone set to a 
   time zone that recognizes DST), this means <TT
CLASS="LITERAL"
>interval '1 day'</TT
> 
   does not necessarily equal <TT
CLASS="LITERAL"
>interval '24 hours'</TT
>. 
   For example, with the session time zone set to <TT
CLASS="LITERAL"
>CST7CDT</TT
>,
   <TT
CLASS="LITERAL"
>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day' </TT
>
   will produce <TT
CLASS="LITERAL"
>timestamp with time zone '2005-04-03 12:00-06'</TT
>, 
   while adding <TT
CLASS="LITERAL"
>interval '24 hours'</TT
> to the same initial 
   <TT
CLASS="TYPE"
>timestamp with time zone</TT
> produces
   <TT
CLASS="LITERAL"
>timestamp with time zone '2005-04-03 13:00-06'</TT
>, as there is
   a change in daylight saving time at <TT
CLASS="LITERAL"
>2005-04-03 02:00</TT
> in time zone 
   <TT
CLASS="LITERAL"
>CST7CDT</TT
>.
  </P
><P
>   Note there can be ambiguity in the <TT
CLASS="LITERAL"
>months</TT
> returned by
   <CODE
CLASS="FUNCTION"
>age</CODE
> because different months have a different number of
   days.  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s approach uses the month from the
   earlier of the two dates when calculating partial months.  For example,
   <TT
CLASS="LITERAL"
>age('2004-06-01', '2004-04-30')</TT
> uses April to yield
   <TT
CLASS="LITERAL"
>1 mon 1 day</TT
>, while using May would yield <TT
CLASS="LITERAL"
>1 mon 2
   days</TT
> because May has 31 days, while April has only 30.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-DATETIME-EXTRACT"
>9.9.1. <CODE
CLASS="FUNCTION"
>EXTRACT</CODE
>, <CODE
CLASS="FUNCTION"
>date_part</CODE
></A
></H2
><PRE
CLASS="SYNOPSIS"
>EXTRACT(<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> FROM <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE
><P
>    The <CODE
CLASS="FUNCTION"
>extract</CODE
> function retrieves subfields
    such as year or hour from date/time values.
    <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
> must be a value expression of
    type <TT
CLASS="TYPE"
>timestamp</TT
>, <TT
CLASS="TYPE"
>time</TT
>, or <TT
CLASS="TYPE"
>interval</TT
>.
    (Expressions of type <TT
CLASS="TYPE"
>date</TT
> are
    cast to <TT
CLASS="TYPE"
>timestamp</TT
> and can therefore be used as
    well.)  <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> is an identifier or
    string that selects what field to extract from the source value.
    The <CODE
CLASS="FUNCTION"
>extract</CODE
> function returns values of type
    <TT
CLASS="TYPE"
>double precision</TT
>.
    The following are valid field names:

    
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>century</TT
></DT
><DD
><P
>        The century
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>20</SAMP
>
SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>21</SAMP
></PRE
><P
>        The first century starts at 0001-01-01 00:00:00 AD, although
        they did not know it at the time. This definition applies to all
        Gregorian calendar countries. There is no century number 0,
        you go from -1 century to 1 century.

        If you disagree with this, please write your complaint to:
        Pope, Cathedral Saint-Peter of Roma, Vatican.
       </P
><P
>        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> releases before 8.0 did not
        follow the conventional numbering of centuries, but just returned
        the year field divided by 100.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>day</TT
></DT
><DD
><P
>        The day (of the month) field (1 - 31)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>16</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>decade</TT
></DT
><DD
><P
>        The year field divided by 10
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>200</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>dow</TT
></DT
><DD
><P
>        The day of the week as Sunday(<TT
CLASS="LITERAL"
>0</TT
>) to
        Saturday(<TT
CLASS="LITERAL"
>6</TT
>)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>5</SAMP
></PRE
><P
>        Note that <CODE
CLASS="FUNCTION"
>extract</CODE
>'s day of the week numbering
        differs from that of the <CODE
CLASS="FUNCTION"
>to_char(...,
        'D')</CODE
> function.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>doy</TT
></DT
><DD
><P
>        The day of the year (1 - 365/366)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>47</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>epoch</TT
></DT
><DD
><P
>        For <TT
CLASS="TYPE"
>date</TT
> and <TT
CLASS="TYPE"
>timestamp</TT
> values, the
        number of seconds since 1970-01-01 00:00:00 UTC (can be negative);
        for <TT
CLASS="TYPE"
>interval</TT
> values, the total number
        of seconds in the interval
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>982384720.12</SAMP
>

SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>442800</SAMP
></PRE
><P
>        Here is how you can convert an epoch value back to a time
        stamp:
       </P
><PRE
CLASS="SCREEN"
>SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720.12 * INTERVAL '1 second';</PRE
><P
>        (The <CODE
CLASS="FUNCTION"
>to_timestamp</CODE
> function encapsulates the above
        conversion.)
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>hour</TT
></DT
><DD
><P
>        The hour field (0 - 23)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>20</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>isodow</TT
></DT
><DD
><P
>        The day of the week as Monday(<TT
CLASS="LITERAL"
>1</TT
>) to
        Sunday(<TT
CLASS="LITERAL"
>7</TT
>)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>7</SAMP
></PRE
><P
>        This is identical to <TT
CLASS="LITERAL"
>dow</TT
> except for Sunday.  This
        matches the <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> 8601 day of the week numbering.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>isoyear</TT
></DT
><DD
><P
>        The <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> 8601 year that the date falls in (not applicable to intervals)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2005</SAMP
>
SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2006</SAMP
></PRE
><P
>        Each <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> year begins with the Monday of the week containing the 4th of January, so in early January or late December the <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> year may be different from the Gregorian year.  See the <TT
CLASS="LITERAL"
>week</TT
> field for more information.
       </P
><P
>        This field is not available in PostgreSQL releases prior to 8.3.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>microseconds</TT
></DT
><DD
><P
>        The seconds field, including fractional parts, multiplied by 1
        000 000;  note that this includes full seconds
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28500000</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>millennium</TT
></DT
><DD
><P
>        The millennium
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>3</SAMP
></PRE
><P
>        Years in the 1900s are in the second millennium.
        The third millennium started January 1, 2001.
       </P
><P
>        <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> releases before 8.0 did not
        follow the conventional numbering of millennia, but just returned
        the year field divided by 1000.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>milliseconds</TT
></DT
><DD
><P
>        The seconds field, including fractional parts, multiplied by
        1000.  Note that this includes full seconds.
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28500</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>minute</TT
></DT
><DD
><P
>        The minutes field (0 - 59)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>38</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>month</TT
></DT
><DD
><P
>        For <TT
CLASS="TYPE"
>timestamp</TT
> values, the number of the month
        within the year (1 - 12) ; for <TT
CLASS="TYPE"
>interval</TT
> values
        the number of months, modulo 12 (0 - 11)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2</SAMP
>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>3</SAMP
>

SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>quarter</TT
></DT
><DD
><P
>        The quarter of the year (1 - 4) that the date is in
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>1</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>second</TT
></DT
><DD
><P
>        The seconds field, including fractional parts (0 -
        59<A
NAME="AEN13266"
HREF="#FTN.AEN13266"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>)
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>40</SAMP
>

SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>28.5</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>timezone</TT
></DT
><DD
><P
>        The time zone offset from UTC, measured in seconds.  Positive values
        correspond to time zones east of UTC, negative values to
        zones west of UTC.
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>timezone_hour</TT
></DT
><DD
><P
>        The hour component of the time zone offset
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>timezone_minute</TT
></DT
><DD
><P
>        The minute component of the time zone offset
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>week</TT
></DT
><DD
><P
>        The number of the week of the year that the day is in.  By definition
        (<ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
> 8601), the first week of a year
        contains January 4 of that year.  (The <ACRONYM
CLASS="ACRONYM"
>ISO</ACRONYM
>-8601
        week starts on Monday.)  In other words, the first Thursday of
        a year is in week 1 of that year.
       </P
><P
>        Because of this, it is possible for early January dates to be part of the 
        52nd or 53rd week of the previous year.  For example, <TT
CLASS="LITERAL"
>2005-01-01</TT
>
        is part of the 53rd week of year 2004, and <TT
CLASS="LITERAL"
>2006-01-01</TT
> is part of 
        the 52nd week of year 2005.
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>7</SAMP
></PRE
></DD
><DT
><TT
CLASS="LITERAL"
>year</TT
></DT
><DD
><P
>        The year field.  Keep in mind there is no <TT
CLASS="LITERAL"
>0 AD</TT
>, so subtracting 
        <TT
CLASS="LITERAL"
>BC</TT
> years from <TT
CLASS="LITERAL"
>AD</TT
> years should be done with care.
       </P
><PRE
CLASS="SCREEN"
>SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001</SAMP
></PRE
></DD
></DL
></DIV
><P>
   </P
><P
>    The <CODE
CLASS="FUNCTION"
>extract</CODE
> function is primarily intended
    for computational processing.  For formatting date/time values for
    display, see <A
HREF="functions-formatting.html"
>Section 9.8</A
>.
   </P
><P
>    The <CODE
CLASS="FUNCTION"
>date_part</CODE
> function is modeled on the traditional
    <SPAN
CLASS="PRODUCTNAME"
>Ingres</SPAN
> equivalent to the
    <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>-standard function <CODE
CLASS="FUNCTION"
>extract</CODE
>:
</P><PRE
CLASS="SYNOPSIS"
>date_part('<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>', <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE
><P>
    Note that here the <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> parameter needs to
    be a string value, not a name.  The valid field names for
    <CODE
CLASS="FUNCTION"
>date_part</CODE
> are the same as for
    <CODE
CLASS="FUNCTION"
>extract</CODE
>.
   </P
><PRE
CLASS="SCREEN"
>SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>16</SAMP
>

SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>4</SAMP
></PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-DATETIME-TRUNC"
>9.9.2. <CODE
CLASS="FUNCTION"
>date_trunc</CODE
></A
></H2
><P
>    The function <CODE
CLASS="FUNCTION"
>date_trunc</CODE
> is conceptually
    similar to the <CODE
CLASS="FUNCTION"
>trunc</CODE
> function for numbers.
   </P
><P
></P><PRE
CLASS="SYNOPSIS"
>date_trunc('<TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
>', <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
>)</PRE
><P>
    <TT
CLASS="REPLACEABLE"
><I
>source</I
></TT
> is a value expression of type
    <TT
CLASS="TYPE"
>timestamp</TT
> or <TT
CLASS="TYPE"
>interval</TT
>.
    (Values of type <TT
CLASS="TYPE"
>date</TT
> and
    <TT
CLASS="TYPE"
>time</TT
> are cast automatically to <TT
CLASS="TYPE"
>timestamp</TT
> or
    <TT
CLASS="TYPE"
>interval</TT
>, respectively.)
    <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> selects to which precision to
    truncate the input value.  The return value is of type
    <TT
CLASS="TYPE"
>timestamp</TT
> or <TT
CLASS="TYPE"
>interval</TT
>
    with all fields that are less significant than the
    selected one set to zero (or one, for day and month).
   </P
><P
>    Valid values for <TT
CLASS="REPLACEABLE"
><I
>field</I
></TT
> are:
    <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>microseconds</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>milliseconds</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>second</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>minute</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>hour</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>day</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>week</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>month</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>quarter</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>year</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>decade</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>century</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>millennium</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
>
   </P
><P
>    Examples:
</P><PRE
CLASS="SCREEN"
>SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 20:00:00</SAMP
>

SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-01-01 00:00:00</SAMP
></PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-DATETIME-ZONECONVERT"
>9.9.3. <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
></A
></H2
><P
>    The <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
> construct allows conversions
    of time stamps to different time zones.  <A
HREF="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT-TABLE"
>Table 9-28</A
> shows its
    variants.
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-DATETIME-ZONECONVERT-TABLE"
></A
><P
><B
>Table 9-28. <TT
CLASS="LITERAL"
>AT TIME ZONE</TT
> Variants</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Expression</TH
><TH
>Return Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>         <TT
CLASS="LITERAL"
><TT
CLASS="TYPE"
>timestamp without time zone</TT
> AT TIME ZONE <TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>Treat given time stamp <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>without time zone</I
></SPAN
> as located in the specified time zone</TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
><TT
CLASS="TYPE"
>timestamp with time zone</TT
> AT TIME ZONE <TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>timestamp without time zone</TT
></TD
><TD
>Convert given time stamp <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>with time zone</I
></SPAN
> to the new time
        zone, with no time zone designation</TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
><TT
CLASS="TYPE"
>time with time zone</TT
> AT TIME ZONE <TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>time with time zone</TT
></TD
><TD
>Convert given time <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>with time zone</I
></SPAN
> to the new time zone</TD
></TR
></TBODY
></TABLE
></DIV
><P
>    In these expressions, the desired time zone <TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
> can be
    specified either as a text string (e.g., <TT
CLASS="LITERAL"
>'PST'</TT
>)
    or as an interval (e.g., <TT
CLASS="LITERAL"
>INTERVAL '-08:00'</TT
>).
    In the text case, a time zone name can be specified in any of the ways
    described in <A
HREF="datatype-datetime.html#DATATYPE-TIMEZONES"
>Section 8.5.3</A
>.
   </P
><P
>    Examples (assuming the local time zone is <TT
CLASS="LITERAL"
>PST8PDT</TT
>):
</P><PRE
CLASS="SCREEN"
>SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 19:38:40-08</SAMP
>

SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-02-16 18:38:40</SAMP
></PRE
><P>
    The first example takes a time stamp without time zone and interprets it as MST time
    (UTC-7), which is then converted to PST (UTC-8) for display.  The second example takes 
    a time stamp specified in EST (UTC-5) and converts it to local time in MST (UTC-7).
   </P
><P
>    The function <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>timezone</CODE
>(<TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
>,
    <TT
CLASS="REPLACEABLE"
><I
>timestamp</I
></TT
>)</TT
> is equivalent to the SQL-conforming construct
    <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>timestamp</I
></TT
> AT TIME ZONE
    <TT
CLASS="REPLACEABLE"
><I
>zone</I
></TT
></TT
>. 
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-DATETIME-CURRENT"
>9.9.4. Current Date/Time</A
></H2
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> provides a number of functions
    that return values related to the current date and time.  These
    SQL-standard functions all return values based on the start time of
    the current transaction:
</P><PRE
CLASS="SYNOPSIS"
>CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
CURRENT_TIMESTAMP(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
LOCALTIME
LOCALTIMESTAMP
LOCALTIME(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)
LOCALTIMESTAMP(<TT
CLASS="REPLACEABLE"
><I
>precision</I
></TT
>)</PRE
><P>
    </P
><P
>     <CODE
CLASS="FUNCTION"
>CURRENT_TIME</CODE
> and
     <CODE
CLASS="FUNCTION"
>CURRENT_TIMESTAMP</CODE
> deliver values with time zone;
     <CODE
CLASS="FUNCTION"
>LOCALTIME</CODE
> and
     <CODE
CLASS="FUNCTION"
>LOCALTIMESTAMP</CODE
> deliver values without time zone.
    </P
><P
>     <CODE
CLASS="FUNCTION"
>CURRENT_TIME</CODE
>,
     <CODE
CLASS="FUNCTION"
>CURRENT_TIMESTAMP</CODE
>,
     <CODE
CLASS="FUNCTION"
>LOCALTIME</CODE
>, and
     <CODE
CLASS="FUNCTION"
>LOCALTIMESTAMP</CODE
>
     can optionally take
     a precision parameter, which causes the result to be rounded
     to that many fractional digits in the seconds field.  Without a precision parameter,
     the result is given to the full available precision.
    </P
><P
>    Some examples:
</P><PRE
CLASS="SCREEN"
>SELECT CURRENT_TIME;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>14:39:53.662522-05</SAMP
>

SELECT CURRENT_DATE;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23</SAMP
>

SELECT CURRENT_TIMESTAMP;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.662522-05</SAMP
>

SELECT CURRENT_TIMESTAMP(2);
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.66-05</SAMP
>

SELECT LOCALTIMESTAMP;
<I
CLASS="LINEANNOTATION"
>Result: </I
><SAMP
CLASS="COMPUTEROUTPUT"
>2001-12-23 14:39:53.662522</SAMP
></PRE
><P>
   </P
><P
>    Since these functions return
    the start time of the current transaction, their values do not
    change during the transaction. This is considered a feature:
    the intent is to allow a single transaction to have a consistent
    notion of the <SPAN
CLASS="QUOTE"
>"current"</SPAN
> time, so that multiple
    modifications within the same transaction bear the same
    time stamp.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     Other database systems might advance these values more
     frequently.
    </P
></BLOCKQUOTE
></DIV
><P
>    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> also provides functions that
    return the start time of the current statement, as well as the actual
    current time at the instant the function is called.  The complete list
    of non-SQL-standard time functions is:
</P><PRE
CLASS="SYNOPSIS"
>transaction_timestamp()
statement_timestamp()
clock_timestamp()
timeofday()
now()</PRE
><P>
   </P
><P
>    <CODE
CLASS="FUNCTION"
>transaction_timestamp()</CODE
> is equivalent to
    <CODE
CLASS="FUNCTION"
>CURRENT_TIMESTAMP</CODE
>, but is named to clearly reflect
    what it returns.
    <CODE
CLASS="FUNCTION"
>statement_timestamp()</CODE
> returns the start time of the current
    statement (more specifically, the time of receipt of the latest command
    message from the client).
    <CODE
CLASS="FUNCTION"
>statement_timestamp()</CODE
> and <CODE
CLASS="FUNCTION"
>transaction_timestamp()</CODE
>
    return the same value during the first command of a transaction, but might
    differ during subsequent commands.
    <CODE
CLASS="FUNCTION"
>clock_timestamp()</CODE
> returns the actual current time, and
    therefore its value changes even within a single SQL command.
    <CODE
CLASS="FUNCTION"
>timeofday()</CODE
> is a historical
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> function.  Like
    <CODE
CLASS="FUNCTION"
>clock_timestamp()</CODE
>, it returns the actual current time,
    but as a formatted <TT
CLASS="TYPE"
>text</TT
> string rather than a <TT
CLASS="TYPE"
>timestamp
    with time zone</TT
> value.
    <CODE
CLASS="FUNCTION"
>now()</CODE
> is a traditional <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    equivalent to <CODE
CLASS="FUNCTION"
>transaction_timestamp()</CODE
>.
   </P
><P
>    All the date/time data types also accept the special literal value
    <TT
CLASS="LITERAL"
>now</TT
> to specify the current date and time (again,
    interpreted as the transaction start time).  Thus,
    the following three all return the same result:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT CURRENT_TIMESTAMP;
SELECT now();
SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT</PRE
><P>
   </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>      You do not want to use the third form when specifying a <TT
CLASS="LITERAL"
>DEFAULT</TT
>
      clause while creating a table.  The system will convert <TT
CLASS="LITERAL"
>now</TT
>
      to a <TT
CLASS="TYPE"
>timestamp</TT
> as soon as the constant is parsed, so that when
      the default value is needed,
      the time of the table creation would be used!  The first two
      forms will not be evaluated until the default value is used,
      because they are function calls.  Thus they will give the desired
      behavior of defaulting to the time of row insertion.
     </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-DATETIME-DELAY"
>9.9.5. Delaying Execution</A
></H2
><P
>    The following function is available to delay execution of the server
    process:
</P><PRE
CLASS="SYNOPSIS"
>pg_sleep(<TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
>)</PRE
><P>

    <CODE
CLASS="FUNCTION"
>pg_sleep</CODE
> makes the current session's process
    sleep until <TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
> seconds have
    elapsed.  <TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
> is a value of type
    <TT
CLASS="TYPE"
>double precision</TT
>, so fractional-second delays can be specified.
    For example:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_sleep(1.5);</PRE
><P>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>      The effective resolution of the sleep interval is platform-specific;
      0.01 seconds is a common value.  The sleep delay will be at least as long
      as specified. It might be longer depending on factors such as server load.
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>      Make sure that your session does not hold more locks than necessary
      when calling <CODE
CLASS="FUNCTION"
>pg_sleep</CODE
>.  Otherwise other sessions
      might have to wait for your sleeping process, slowing down the entire
      system.
     </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN13266"
HREF="functions-datetime.html#AEN13266"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>60 if leap seconds are
        implemented by the operating system</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-formatting.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-enum.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Data Type Formatting Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Enum Support Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>